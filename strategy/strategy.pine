//@version=5
// 매직1분VN - 경량 최적화 프로파일
// 필수 신호(스퀴즈 모멘텀·방향성 플럭스)와 기본 필터만 남긴 버전입니다.

strategy(
     title                   = "매직1분VN (Optimizer Profile)",
     overlay                 = true,
     pyramiding              = 0,
     initial_capital         = 500,
     default_qty_type        = strategy.fixed,
     default_qty_value       = 1,
     commission_type         = strategy.commission.percent,
     commission_value        = 0.05,
     process_orders_on_close = true,
     calc_on_every_tick      = false
)

// === Colour Palette ===
const color colup = #ffcfa6
const color coldn = #419fec
const color colpf = #ffd0a6
const color coldf = #4683b4
const color colps = #169b5d
const color colng = #970529
const color colpo = #11cf77
const color colno = #d11645
const color colsh = #ff1100
const color colsm = #ff5e00

// =================================================================================
// === 설정 (Inputs) ==============================================================
// =================================================================================

// --- 1. 스퀴즈 모멘텀 ---
gOsc  = "1. 스퀴즈 모멘텀"
showMomentum = input.bool(true , title="모멘텀 히스토그램 표시" , group=gOsc)
len          = input.int (12   , title="Momentum Length"       , group=gOsc, minval=5 , maxval=100)
sig          = input.int (3    , title="Signal Length"         , group=gOsc, minval=1 , maxval=20)
bbLen        = input.int (20   , title="BB Length"             , group=gOsc, minval=5 , maxval=200)
bbMult       = input.float(1.4 , title="BB Multiplier"         , group=gOsc, minval=0.1, maxval=5.0 , step=0.1)
kcLen        = input.int (18   , title="KC Length (ATR)"       , group=gOsc, minval=5 , maxval=200)
kcMult       = input.float(1.0 , title="KC Multiplier"         , group=gOsc, minval=0.1, maxval=5.0 , step=0.1)

// --- 2. 방향성 플럭스 ---
gDF   = "2. 방향성 플럭스"
showFlux    = input.bool(true , title="플럭스 시각화"         , group=gDF)
dfl          = input.int (14  , title="Flux Length"           , group=gDF, minval=5 , maxval=100)
dfSmoothLen  = input.int (1   , title="플럭스 스무딩"          , group=gDF, minval=1 , maxval=50)
dfh          = input.bool(true, title="Heikin-Ashi 변환 사용" , group=gDF)

// --- 6. 모디파이드 옵션 ---
gMod = "6. 모디파이드"
// 모디파이드 DMI/ADX 기반 방향성 플럭스 사용 여부
useModFlux   = input.bool(false, title="모디파이드 플럭스(DMI/ADX) 사용" , group=gMod)
// 모디파이드 스퀴즈 모멘텀(ATR 정규화) 사용 여부
useModSqueeze = input.bool(false, title="모디파이드 스퀴즈모멘텀(ATR) 사용" , group=gMod)
// 모멘텀 신호선 이평선 종류: 기본(SMA), EMA, HMA
maType       = input.string("기본", title="모멘텀 신호선 타입", options=["기본","EMA","HMA"], group=gMod)
// --- 3. 청산 옵션 ---
gExit = "3. 청산 옵션"
exitOpposite = input.bool(true , title="반대 신호 청산"      , group=gExit)
useMomFade   = input.bool(false, title="모멘텀 페이드 청산"  , group=gExit)
fadeMode     = input.string("VN", title="페이드 모드", options=["VN", "Legacy"], group=gExit)
useAtrStop   = input.bool(true , title="ATR 손절 사용"        , group=gExit)
atrStopMult  = input.float(1.5 , title="ATR 손절 Mult"        , group=gExit, minval=0.1, maxval=5.0, step=0.1)
useFixedStop = input.bool(false, title="고정 % 손절"          , group=gExit)
fixedStopPct = input.float(0.8 , title="고정 손절 %"         , group=gExit, minval=0.1, maxval=5.0, step=0.1)
useStopLoss  = input.bool(false, title="전고/전저 손절"       , group=gExit)
stopLookback = input.int (5    , title="전고/전저 탐색"      , group=gExit, minval=2, maxval=50)
usePivotStop = input.bool(false, title="피봇 손절"            , group=gExit)
pivotLen     = input.int (5    , title="피봇 길이"           , group=gExit, minval=2, maxval=20)
useAtrTrail  = input.bool(false, title="ATR 트레일"           , group=gExit)
atrTrailLen  = input.int (14   , title="ATR 트레일 길이"      , group=gExit, minval=1, maxval=200)
atrTrailMult = input.float(2.0 , title="ATR 트레일 Mult"      , group=gExit, minval=0.1, maxval=5.0, step=0.1)
useBreakeven = input.bool(false, title="브레이크이븐 스탑"    , group=gExit)
breakevenMult= input.float(1.0 , title="브레이크이븐 ATR Mult", group=gExit, minval=0.1, maxval=5.0, step=0.1)
useTimeStop  = input.bool(false, title="시간 손절"            , group=gExit)
maxHoldBars  = input.int (0    , title="최대 보유 봉 수"      , group=gExit, minval=0, maxval=200)

// --- 4. 필터 ---
gFilt = "4. 필터"
useHtfTrend    = input.bool(false, title="상위 타임프레임 추세 필터", group=gFilt)
htfTrendTf     = input.timeframe("240", title="상위 타임프레임"      , group=gFilt)
htfMaLen       = input.int (50   , title="상위봉 EMA Length"       , group=gFilt, minval=5, maxval=400)
useRangeFilter = input.bool(false, title="상위봉 레인지 필터", group=gFilt)
rangeTf        = input.timeframe("5", title="레인지 측정 TF" , group=gFilt)
rangeBars      = input.int (20  , title="레인지 측정 봉 수"  , group=gFilt, minval=5, maxval=200)
rangePercent   = input.float(1.0, title="레인지 한계 (%)"    , group=gFilt, minval=0.1, maxval=10.0, step=0.1)

gMsg = "5. 알림"
alertLongEntry  = input.string('{"action":"enter_long"}', title="롱 진입", group=gMsg)
alertShortEntry = input.string('{"action":"enter_short"}', title="숏 진입", group=gMsg)
alertExitLong   = input.string('{"action":"exit_long"}', title="롱 청산", group=gMsg)
alertExitShort  = input.string('{"action":"exit_short"}', title="숏 청산", group=gMsg)

// =================================================================================
// === 보조 계산 ==================================================================
// =================================================================================

// --- Heikin-Ashi 변환 ---
float haClose = (open + high + low + close) / 4.0
var float haOpen = na
haOpen := na(haOpen[1]) ? (open + close) / 2.0 : (haOpen[1] + haClose[1]) / 2.0
float haHigh = math.max(high, math.max(haOpen, haClose))
float haLow  = math.min(low,  math.min(haOpen, haClose))

float srcClose = dfh ? haClose : close

// --- 플럭스 계산 (Deluxe 방식) ---
float fluxHigh   = dfh ? haHigh : high
float fluxLow    = dfh ? haLow  : low
float fluxClose  = srcClose
float prevClose  = nz(fluxClose[1], fluxClose)
float upMove     = fluxHigh - nz(fluxHigh[1], fluxHigh)
float downMove   = nz(fluxLow[1], fluxLow) - fluxLow
float trRaw      = math.max(fluxHigh - fluxLow, math.max(math.abs(fluxHigh - prevClose), math.abs(fluxLow - prevClose)))
float tr         = ta.rma(trRaw, dfl)
float upRma      = ta.rma(math.max(upMove, 0.0), dfl)
float downRma    = ta.rma(math.max(downMove, 0.0), dfl)
float trSafe     = tr == 0.0 ? na : tr
float up         = not na(trSafe) ? upRma / trSafe : 0.0
float dn         = not na(trSafe) ? downRma / trSafe : 0.0
float fluxDenom  = up + dn
float fluxRatio  = fluxDenom != 0 ? (up - dn) / fluxDenom : 0.0
int   fluxHalf   = math.max(int(math.round(dfl / 2.0)), 1)
float fluxCore   = ta.rma(fluxRatio, fluxHalf) * 100.0
float fluxValOriginal = dfSmoothLen > 1 ? ta.sma(fluxCore, dfSmoothLen) : fluxCore

// 모디파이드 방향성 플럭스 (DMI/ADX) 계산
float pdi       = ta.plus_di(dfl)
float ndi       = ta.minus_di(dfl)
float dden      = pdi + ndi
float modFluxRatio = dden != 0 ? (pdi - ndi) / dden : 0.0
int   modFluxHalf   = math.max(int(math.round(dfl / 2.0)), 1)
float modFluxCore   = ta.rma(modFluxRatio, modFluxHalf) * 100.0
float modFluxVal    = dfSmoothLen > 1 ? ta.sma(modFluxCore, dfSmoothLen) : modFluxCore

// 최종 사용될 플럭스
float fluxVal    = useModFlux ? modFluxVal : fluxValOriginal

// --- 스퀴즈 모멘텀 계산 ---
float bbBasis = ta.sma(close, bbLen)
float bbDev   = ta.stdev(close, bbLen) * bbMult
float kcRange = ta.atr(kcLen) * kcMult
bool squeezeOn = bbDev < kcRange

float hl2         = (high + low) / 2.0
float kcBasis     = ta.sma(hl2, kcLen)
float kcUpper     = kcBasis + kcRange
float kcLower     = kcBasis - kcRange
float kcAverage   = (kcUpper + kcLower) / 2.0
float midline     = math.avg(hl2, kcAverage)
float atrPrimary  = ta.atr(kcLen)
// 기본/모디파이드 스퀴즈 모멘텀 입력값
float normOriginal = (close - midline)
float normMod      = atrPrimary > 0 ? (close - midline) / atrPrimary : 0.0
float normSel      = useModSqueeze ? normMod : normOriginal
// 100 배율을 맞춰 비교적 일관된 크기를 유지
float momentum    = ta.linreg(normSel * 100.0, len, 0)
// 모멘텀 신호선 타입별 계산
float momSignal   = na
if maType == "EMA"
    momSignal := ta.ema(momentum, sig)
else if maType == "HMA"
    momSignal := ta.hma(momentum, sig)
else
    momSignal := ta.sma(momentum, sig)

// --- 페이드 감지 ---
int fadeWindow = 1
bool fadeMagnitudeDown = ta.falling(math.abs(momentum), fadeWindow)
bool fadeLongCond_vn  = momentum > 0 and fadeMagnitudeDown
bool fadeShortCond_vn = momentum < 0 and fadeMagnitudeDown
bool fadeLongCond_lg  = momentum > 0 and momentum <= nz(momentum[1], momentum)
bool fadeShortCond_lg = momentum < 0 and momentum >= nz(momentum[1], momentum)
bool fadeLongCond  = fadeMode == "VN" ? fadeLongCond_vn  : fadeLongCond_lg
bool fadeShortCond = fadeMode == "VN" ? fadeShortCond_vn : fadeShortCond_lg

// --- 상위봉 필터 ---
// 상위봉 필터는 사용 시에만 계산
float htfMa      = na
bool htfTrendUp  = false
bool htfTrendDown= false
if useHtfTrend
    htfMa      := request.security(syminfo.tickerid, htfTrendTf, ta.ema(close, htfMaLen), lookahead=barmerge.lookahead_off)
    htfTrendUp   := close > htfMa
    htfTrendDown := close < htfMa

// --- 레인지 필터 ---
float rangeHigh   = na
float rangeLow    = na
float rangePerc   = na
bool  inRangeBox  = false
if useRangeFilter
    rangeHigh   := request.security(syminfo.tickerid, rangeTf, ta.highest(high, rangeBars), lookahead=barmerge.lookahead_off)
    rangeLow    := request.security(syminfo.tickerid, rangeTf, ta.lowest(low, rangeBars),  lookahead=barmerge.lookahead_off)
    rangePerc   := rangeLow != 0 ? (rangeHigh - rangeLow) / rangeLow * 100.0 : 0.0
    inRangeBox  := rangePerc <= rangePercent

float pivotLow = ta.valuewhen(not na(ta.pivotlow(low, pivotLen, pivotLen)), ta.pivotlow(low, pivotLen, pivotLen), 0)
float pivotHigh = ta.valuewhen(not na(ta.pivothigh(high, pivotLen, pivotLen)), ta.pivothigh(high, pivotLen, pivotLen), 0)
float swingLow = ta.lowest(low, stopLookback)
float swingHigh = ta.highest(high, stopLookback)
float atrBase = ta.atr(len)
float atrTrailBase = ta.atr(atrTrailLen)

// =================================================================================
// === 신호 & 실행 =================================================================
// =================================================================================

bool longSignal  = ta.crossover(momentum, momSignal) and momentum < 0 and fluxVal > 0
bool shortSignal = ta.crossunder(momentum, momSignal) and momentum > 0 and fluxVal < 0

bool longFilterOk  = (not useHtfTrend or htfTrendUp)   and (not useRangeFilter or not inRangeBox)
bool shortFilterOk = (not useHtfTrend or htfTrendDown) and (not useRangeFilter or not inRangeBox)

bool enterLong  = longSignal  and longFilterOk
bool enterShort = shortSignal and shortFilterOk

bool exitLongOpposite  = exitOpposite and shortSignal
bool exitShortOpposite = exitOpposite and longSignal
bool exitLongFade      = useMomFade and fadeLongCond
bool exitShortFade     = useMomFade and fadeShortCond

var float highestSinceEntry = na
var float lowestSinceEntry  = na
var int   holdBars          = 0

if barstate.isconfirmed
    if strategy.position_size == 0
        holdBars := 0
        highestSinceEntry := na
        lowestSinceEntry := na
        strategy.cancel("LongStop")
        strategy.cancel("ShortStop")
        if enterLong
            strategy.entry("Long", strategy.long, alert_message=alertLongEntry)
        if enterShort
            strategy.entry("Short", strategy.short, alert_message=alertShortEntry)
    else
        holdBars += 1
        if strategy.position_size > 0
            highestSinceEntry := na(highestSinceEntry) ? high : math.max(highestSinceEntry, high)
            float breakevenStop = na
            if useBreakeven and not na(highestSinceEntry) and not na(atrTrailBase)
                breakevenStop := (highestSinceEntry - strategy.position_avg_price) >= atrTrailBase * breakevenMult ? strategy.position_avg_price : na
            float trailStop = useAtrTrail and not na(highestSinceEntry) and not na(atrTrailBase) ? highestSinceEntry - atrTrailMult * atrTrailBase : na
            float combinedStop = na
            if useBreakeven and not na(breakevenStop)
                combinedStop := breakevenStop
            if useStopLoss and not na(swingLow)
                combinedStop := na(combinedStop) ? swingLow : math.max(combinedStop, swingLow)
            if usePivotStop and not na(pivotLow)
                combinedStop := na(combinedStop) ? pivotLow : math.max(combinedStop, pivotLow)
            if useAtrTrail and not na(trailStop)
                combinedStop := na(combinedStop) ? trailStop : math.max(combinedStop, trailStop)
            if useFixedStop
                float fixedStop = strategy.position_avg_price * (1 - fixedStopPct / 100.0)
                combinedStop := na(combinedStop) ? fixedStop : math.max(combinedStop, fixedStop)
            if useAtrStop and not na(atrBase)
                float atrStopVal = strategy.position_avg_price - atrBase * atrStopMult
                combinedStop := na(combinedStop) ? atrStopVal : math.max(combinedStop, atrStopVal)
            if not na(combinedStop)
                strategy.exit("LongStop", from_entry="Long", stop=combinedStop, alert_message=alertExitLong)
            if useTimeStop and maxHoldBars > 0 and holdBars >= maxHoldBars
                strategy.close("Long", alert_message=alertExitLong)
            else if exitLongOpposite or (exitLongFade and holdBars >= 1)
                strategy.close("Long", alert_message=alertExitLong)
        else if strategy.position_size < 0
            lowestSinceEntry := na(lowestSinceEntry) ? low : math.min(lowestSinceEntry, low)
            float breakevenStop = na
            if useBreakeven and not na(lowestSinceEntry) and not na(atrTrailBase)
                breakevenStop := (strategy.position_avg_price - lowestSinceEntry) >= atrTrailBase * breakevenMult ? strategy.position_avg_price : na
            float trailStop = useAtrTrail and not na(lowestSinceEntry) and not na(atrTrailBase) ? lowestSinceEntry + atrTrailMult * atrTrailBase : na
            float combinedStop = na
            if useBreakeven and not na(breakevenStop)
                combinedStop := breakevenStop
            if useStopLoss and not na(swingHigh)
                combinedStop := na(combinedStop) ? swingHigh : math.min(combinedStop, swingHigh)
            if usePivotStop and not na(pivotHigh)
                combinedStop := na(combinedStop) ? pivotHigh : math.min(combinedStop, pivotHigh)
            if useAtrTrail and not na(trailStop)
                combinedStop := na(combinedStop) ? trailStop : math.min(combinedStop, trailStop)
            if useFixedStop
                float fixedStop = strategy.position_avg_price * (1 + fixedStopPct / 100.0)
                combinedStop := na(combinedStop) ? fixedStop : math.min(combinedStop, fixedStop)
            if useAtrStop and not na(atrBase)
                float atrStopVal = strategy.position_avg_price + atrBase * atrStopMult
                combinedStop := na(combinedStop) ? atrStopVal : math.min(combinedStop, atrStopVal)
            if not na(combinedStop)
                strategy.exit("ShortStop", from_entry="Short", stop=combinedStop, alert_message=alertExitShort)
            if useTimeStop and maxHoldBars > 0 and holdBars >= maxHoldBars
                strategy.close("Short", alert_message=alertExitShort)
            else if exitShortOpposite or (exitShortFade and holdBars >= 1)
                strategy.close("Short", alert_message=alertExitShort)

// =================================================================================
// === 시각화 =====================================================================
// =================================================================================

hline(0, title="Zero", color=color.new(color.white, 80), linestyle=hline.style_dashed)
plot(showMomentum ? momentum : na, title="Momentum", color=momentum >= 0 ? colup : coldn, style=plot.style_columns)
plot(showMomentum ? momSignal : na, title="Momentum Signal", color=color.new(color.white, 0))
plot(showFlux ? fluxVal : na, title="Directional Flux", color=fluxVal >= 0 ? colps : colng)
plotshape(enterLong , title="Long Entry" , style=shape.triangleup  , location=location.belowbar, color=colpo, size=size.tiny)
plotshape(enterShort, title="Short Entry", style=shape.triangledown, location=location.abovebar, color=colno, size=size.tiny)
plotshape(exitLongOpposite or exitLongFade , title="Long Exit" , style=shape.circle, location=location.abovebar, color=colpf, size=size.tiny)
plotshape(exitShortOpposite or exitShortFade, title="Short Exit", style=shape.circle, location=location.belowbar, color=coldf, size=size.tiny)
barcolor(squeezeOn ? color.new(colsh, 70) : na)

// --- 얼럿 ---
alertcondition(enterLong , "Enter Long" , "Enter Long")
alertcondition(enterShort, "Enter Short", "Enter Short")
alertcondition(exitLongOpposite or exitLongFade , "Exit Long" , "Exit Long")
alertcondition(exitShortOpposite or exitShortFade, "Exit Short", "Exit Short")
