//@version=5
// PPP 비시바 알고 - 경량 최적화 프로파일
// 필수 신호(UT Bot + StochRSI)와 기본 청산 로직만 남긴 버전입니다.

strategy(
    title                   = "PPP Vishva Algo (Optimizer Profile)",
    overlay                 = true,
    pyramiding              = 0,
    initial_capital         = 1000,
    default_qty_type        = strategy.percent_of_equity,
    default_qty_value       = 100,
    commission_type         = strategy.commission.percent,
    commission_value        = 0.05,
    process_orders_on_close = true,
    calc_on_every_tick      = false
)

// === 그룹 정의 ===
var grp_ut     = "1. UT Bot"
var grp_stoch  = "2. StochRSI"
var grp_exit   = "3. 청산"
var grp_misc   = "4. 기타"
var grp_alerts = "5. 알림"

// === UT Bot ===
utKey        = input.float(4.0,  "UT Key (ATR 배수)", 0.5, 10.0, 0.1, group=grp_ut)
utAtrLen     = input.int(10,     "UT ATR 길이",       1, 100, group=grp_ut)
useHeikin    = input.bool(false, "Heikin-Ashi 소스", group=grp_ut)

// === StochRSI ===
rsiLen   = input.int(14,  "RSI 길이", 2, 100, group=grp_stoch)
stochLen = input.int(14,  "Stoch 길이", 2, 100, group=grp_stoch)
kLen     = input.int(3,   "%K", 1, 50, group=grp_stoch)
dLen     = input.int(3,   "%D", 1, 50, group=grp_stoch)
obLevel  = input.float(80, "과매수", 50, 100, group=grp_stoch)
osLevel  = input.float(20, "과매도", 0, 50, group=grp_stoch)
stMode   = input.string("Bounce", "시그널 모드", ["Bounce", "Cross"], group=grp_stoch)

// === 청산 ===
atrLen         = input.int(14,   "ATR 길이",        1, 100, group=grp_exit)
initStopMult   = input.float(1.8, "초기 손절 ATR 배수", 0.5, 5.0, 0.1, group=grp_exit)
trailAtrMult   = input.float(2.5, "ATR 트레일 배수",    0.5, 8.0, 0.1, group=grp_exit)
trailStartPct  = input.float(1.0, "퍼센트 트레일 시작 %", 0.1, 20.0, 0.1, group=grp_exit)
trailGapPct    = input.float(0.5, "퍼센트 트레일 간격 %", 0.1, 10.0, 0.05, group=grp_exit)
usePercentStop = input.bool(true, "퍼센트 손절/익절", group=grp_exit)
stopPct        = input.float(1.5, "고정 손절 %", 0.1, 20.0, 0.1, group=grp_exit)
takePct        = input.float(2.5, "고정 익절 %", 0.1, 40.0, 0.1, group=grp_exit)
breakevenPct   = input.float(0.0, "브레이크이븐 오프셋 %", 0.0, 5.0, 0.05, group=grp_exit)
maxHoldBars    = input.int(0,    "최대 보유 봉수 (0=제한 없음)", 0, 5000, group=grp_exit)
useFlipExit    = input.bool(true, "UT 반대 신호 청산", group=grp_exit)

// === 기타 ===
cooldownBars = input.int(0, "손실 후 쿨다운 봉", 0, 500, group=grp_misc)

// === 알림 ===
alertLongEntry  = input.string('{"action":"open","side":"long"}',  "롱 진입", group=grp_alerts)
alertShortEntry = input.string('{"action":"open","side":"short"}', "숏 진입", group=grp_alerts)
alertLongExit   = input.string('{"action":"close","side":"long"}',  "롱 청산", group=grp_alerts)
alertShortExit  = input.string('{"action":"close","side":"short"}', "숏 청산", group=grp_alerts)

// === 보조 계산 ===
float haClose = (open + high + low + close) / 4.0
var float haOpen = na
haOpen := na(haOpen[1]) ? (open + close) / 2.0 : (haOpen[1] + haClose[1]) / 2.0
float srcClose = useHeikin ? haClose : close

float atrUt = ta.atr(utAtrLen)
float nLoss = utKey * atrUt
var float trail = na
trail := na(trail[1]) ? (srcClose - nLoss) :
     (srcClose > trail[1] and srcClose[1] > trail[1] ? math.max(trail[1], srcClose - nLoss) :
     (srcClose < trail[1] and srcClose[1] < trail[1] ? math.min(trail[1], srcClose + nLoss) :
     (srcClose > trail[1] ? srcClose - nLoss : srcClose + nLoss)))
float ema1 = ta.ema(srcClose, 1)
bool utBuy  = (srcClose > trail) and ta.crossover(ema1, trail)
bool utSell = (srcClose < trail) and ta.crossover(trail, ema1)

float rsiVal = ta.rsi(close, rsiLen)
float stochVal = ta.stoch(rsiVal, rsiVal, rsiVal, stochLen)
float k = ta.sma(stochVal, kLen)
float d = ta.sma(k, dLen)

bool stLong = stMode == "Bounce" ? (k < osLevel and ta.crossover(k, d)) : (ta.crossover(k, d) and k < 50)
bool stShort = stMode == "Bounce" ? (k > obLevel and ta.crossunder(k, d)) : (ta.crossunder(k, d) and k > 50)

bool longSignal  = utBuy  and stLong
bool shortSignal = utSell and stShort

var int cooldown = 0
if barstate.isconfirmed
    if cooldown > 0
        cooldown -= 1

bool canLong  = longSignal  and strategy.position_size <= 0 and cooldown == 0
bool canShort = shortSignal and strategy.position_size >= 0 and cooldown == 0

float atrVal = ta.atr(atrLen)

// === 진입 ===
if barstate.isconfirmed
    if canLong
        strategy.entry("Long", strategy.long, alert_message=alertLongEntry)
    if canShort
        strategy.entry("Short", strategy.short, alert_message=alertShortEntry)

// === 스탑 & 트레일 ===
float beOffset = breakevenPct / 100.0
float trailStart = trailStartPct / 100.0
float trailGap = trailGapPct / 100.0
float stopPctVal = stopPct / 100.0
float takePctVal = takePct / 100.0

bool longTrailActive  = strategy.position_size > 0 and close >= strategy.position_avg_price * (1 + trailStart)
bool shortTrailActive = strategy.position_size < 0 and close <= strategy.position_avg_price * (1 - trailStart)

float longTrail  = longTrailActive  ? close * (1 - trailGap) : na
float shortTrail = shortTrailActive ? close * (1 + trailGap) : na
float longAtrTrail  = strategy.position_size > 0 and not na(atrVal) ? close - atrVal * trailAtrMult : na
float shortAtrTrail = strategy.position_size < 0 and not na(atrVal) ? close + atrVal * trailAtrMult : na

float longStopAtr  = strategy.position_size > 0 and not na(atrVal) ? strategy.position_avg_price - atrVal * initStopMult : na
float shortStopAtr = strategy.position_size < 0 and not na(atrVal) ? strategy.position_avg_price + atrVal * initStopMult : na

float longStopPct  = strategy.position_size > 0 and usePercentStop ? strategy.position_avg_price * (1 - stopPctVal) : na
float shortStopPct = strategy.position_size < 0 and usePercentStop ? strategy.position_avg_price * (1 + stopPctVal) : na
float longTakePct  = strategy.position_size > 0 and usePercentStop ? strategy.position_avg_price * (1 + takePctVal) : na
float shortTakePct = strategy.position_size < 0 and usePercentStop ? strategy.position_avg_price * (1 - takePctVal) : na

float longBe  = strategy.position_size > 0 ? strategy.position_avg_price * (1 + beOffset) : na
float shortBe = strategy.position_size < 0 ? strategy.position_avg_price * (1 - beOffset) : na

float longStop  = na
float shortStop = na

if strategy.position_size > 0
    longStop := math.max(longStopAtr, na(longStop) ? longStopAtr : longStop)
    if usePercentStop and not na(longStopPct)
        longStop := na(longStop) ? longStopPct : math.max(longStop, longStopPct)
    if not na(longBe) and high >= longBe
        longStop := na(longStop) ? longBe : math.max(longStop, longBe)
    if not na(longTrail)
        longStop := na(longStop) ? longTrail : math.max(longStop, longTrail)
    if not na(longAtrTrail)
        longStop := na(longStop) ? longAtrTrail : math.max(longStop, longAtrTrail)
    strategy.exit("LongExit", from_entry="Long", stop=longStop, limit=longTakePct, alert_message=alertLongExit)

if strategy.position_size < 0
    shortStop := math.min(shortStopAtr, na(shortStop) ? shortStopAtr : shortStop)
    if usePercentStop and not na(shortStopPct)
        shortStop := na(shortStop) ? shortStopPct : math.min(shortStop, shortStopPct)
    if not na(shortBe) and low <= shortBe
        shortStop := na(shortStop) ? shortBe : math.min(shortStop, shortBe)
    if not na(shortTrail)
        shortStop := na(shortStop) ? shortTrail : math.min(shortStop, shortTrail)
    if not na(shortAtrTrail)
        shortStop := na(shortStop) ? shortAtrTrail : math.min(shortStop, shortAtrTrail)
    strategy.exit("ShortExit", from_entry="Short", stop=shortStop, limit=shortTakePct, alert_message=alertShortExit)

// === 기타 종료 조건 ===
if barstate.isconfirmed
    if maxHoldBars > 0 and strategy.position_size != 0
        entryBar = strategy.opentrades > 0 ? strategy.opentrades.entry_bar_index(0) : na
        if not na(entryBar) and bar_index - entryBar >= maxHoldBars
            strategy.close_all(comment="MaxHold", alert_message=strategy.position_size > 0 ? alertLongExit : alertShortExit)
    if useFlipExit and strategy.position_size > 0 and utSell
        strategy.close("Long", comment="UTFlip", alert_message=alertLongExit)
    if useFlipExit and strategy.position_size < 0 and utBuy
        strategy.close("Short", comment="UTFlip", alert_message=alertShortExit)

// === 손실 후 쿨다운 ===
if barstate.isconfirmed and strategy.closedtrades > strategy.closedtrades[1]
    lastIdx = strategy.closedtrades - 1
    float pl = strategy.closedtrades.profit(lastIdx)
    if pl < 0
        cooldown := cooldownBars

// === 시각화 ===
plot(trail, "UT Trail", color=color.new(color.yellow, 0))
plotshape(utBuy,  "UT Buy",  shape.triangleup,   location.belowbar, color.new(color.lime,0), size=size.tiny)
plotshape(utSell, "UT Sell", shape.triangledown, location.abovebar, color.new(color.red,0),  size=size.tiny)

alertcondition(longSignal,  title="LONG_ENTRY", message=alertLongEntry)
alertcondition(shortSignal, title="SHORT_ENTRY", message=alertShortEntry)
alertcondition(strategy.position_size > 0 and (longStop > 0 or na(longStop) == false), title="LONG_EXIT", message=alertLongExit)
alertcondition(strategy.position_size < 0 and (shortStop > 0 or na(shortStop) == false), title="SHORT_EXIT", message=alertShortExit)
