//@version=5
// ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
// ‚ïë Îß§ÏßÅ1Î∂ÑVN ‚Äî Python Î∞±ÌÖåÏä§Ìä∏ ÏóîÏßÑÍ≥º ÎèôÎì±Ìïú TradingView ÏµúÏ¢ÖÎ≥∏ (ÏòàÍ≤¨Ìé∏Ìñ• ÏàòÏ†ï) ‚ïë
// ‚ïë ÏõêÎ≥∏ Python Íµ¨ÌòÑÏùÑ Pine Script v5 Î°ú 1:1 Î°úÏßÅ Ïù¥ÏãùÌïú Î≤ÑÏ†Ñ ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ‚ïë
// ‚ïë Author: OpenAI gpt-5-codex (for Basemodule ÌîÑÎ°úÏ†ùÌä∏) ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬†‚ïë
// ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
// Gemini ÏàòÏ†ï (2025-10-10): f_htf Ìï®Ïàò Î∞è Í¥ÄÎ†® Ìò∏Ï∂úÎ∂Ä ÏàòÏ†ï (request.security mutable variable ÏóêÎü¨ Ìï¥Í≤∞)
// üí° Î¶¨ÌéòÏù∏ÌåÖ ÏàòÏ†ï (2025-10-10): f_htf ÎÇ¥ ÏÉÅÏúÑ ÌÉÄÏûÑÌîÑÎ†àÏûÑ ÌôïÏ†ï Í∞íÎßå ÏÇ¨Ïö©ÌïòÎèÑÎ°ù Ïã§ÏãúÍ∞Ñ Íµ¨Í∞ÑÏóê ÌïúÌï¥ Ïù¥Ï†Ñ Î¥âÏúºÎ°ú ÏûêÎèô Î≥¥Ï†ï (Í≤ΩÍ≥† Ï†úÍ±∞ & Non-Repainting Ïú†ÏßÄ)
// üêû Î°úÏßÅ ÏàòÏ†ï (2025-10-11): 'Deluxe' Î∞è 'KC' Î™®Î©òÌÖÄ Ïä§ÌÉÄÏùº Ï†ïÍ∑úÌôî Î°úÏßÅ ÎàÑÎùΩ ÏàòÏ†ï (Gemini)
strategy('ÌÜµÌï©Î™®Î©òÌÖÄ (Python Ìè¨Ìä∏)',
         overlay=true,
         process_orders_on_close=true,
         calc_on_every_tick=false,          // Ï¢ÖÍ∞Ä Í∏∞Ï§Ä Í≥ÑÏÇ∞ÏúºÎ°ú ÏùºÍ¥ÄÏÑ± Í∞ïÌôî
   
         pyramiding=0,
         initial_capital=500,
         commission_type=strategy.commission.percent,
         commission_value=0.05,
         currency=currency.USD,
         max_lines_count=500,
         max_labels_count=500)

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Í∑∏Î£π ÏÉÅÏàò
var GRP_CORE     = 'üÖê ÏΩîÏñ¥ Î™®Î©òÌÖÄ'
var GRP_FLUX     = 'üÖë ÌîåÎü≠Ïä§ & Ïä§ÌÄ¥Ï¶à'
var GRP_THRESH   = 'üÖí ÏûÑÍ≥ÑÍ∞í'
var GRP_FILTER   = 'üÖì ÌïÑÌÑ∞ & Íµ¨Ï°∞'
var GRP_GUARD    = 'üÖî Í∞ÄÎìú'
var GRP_RISK     = 'üÖï Î¶¨Ïä§ÌÅ¨ & ÏÇ¨Ïù¥Ïßï'
var GRP_EXIT     = 'üÖñ Ï∂úÍµ¨ Í¥ÄÎ¶¨'
var GRP_MISC     = 'üÖó Í∏∞ÌÉÄ'
var GRP_UI       = 'üÖò HUD & ÏãúÍ∞ÅÌôî'

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// ÌïµÏã¨ ÏûÖÎ†• (Python run_backtest ÌååÎùºÎØ∏ÌÑ∞ Î∞òÏòÅ)
oscLen            = input.int(20, 'Ïò§Ïã§Î†àÏù¥ÌÑ∞ Í∏∏Ïù¥', minval=1, group=GRP_CORE, inline='OSC_LEN')
signalLen         = input.int(3, 'Ïã†Ìò∏ÏÑ† Í∏∏Ïù¥', minval=1, group=GRP_CORE, inline='OSC_LEN')
maTypeInput       = input.string('SMA', 'Ïã†Ìò∏ÏÑ† ÌÉÄÏûÖ', options=['SMA', 'EMA', 'HMA'], group=GRP_CORE, inline='OSC_STYLE')
useSameLen        = input.bool(false, 'BB/KC Í∏∏Ïù¥ ÎèôÏùº Ï†ÅÏö©', group=GRP_CORE, inline='BB_FLAG')
bbLen             = input.int(20, 'Î≥ºÎ¶∞Ï†Ä Í∏∏Ïù¥', minval=1, group=GRP_CORE, tooltip='useSameLen ÌôúÏÑ±Ìôî Ïãú oscLenÍ≥º ÎèôÏùº', inline='BB_CONF')
bbMult            = input.float(1.4, 'BB Î∞∞Ïàò', minval=0.1, group=GRP_CORE, inline='BB_CONF')
kcLen             = input.int(18, 'ÏºàÌä∏ÎÑà Í∏∏Ïù¥', minval=1, group=GRP_CORE, tooltip='useSameLen ÌôúÏÑ±Ìôî Ïãú oscLenÍ≥º ÎèôÏùº', inline='KC_CONF')
kcMult            = input.float(1.0, 'KC Î∞∞Ïàò', minval=0.1, group=GRP_CORE, inline='KC_CONF')

fluxLen           = input.int(14, 'ÌîåÎü≠Ïä§ Í∏∏Ïù¥', minval=1, group=GRP_FLUX, inline='FLUX_LEN')
fluxSmoothLen     = input.int(1, 'ÌîåÎü≠Ïä§ Ïä§Î¨¥Îî©', minval=1, group=GRP_FLUX, inline='FLUX_LEN')
useFluxHeikin     = input.bool(true, 'ÌîåÎü≠Ïä§ Heikin-Ashi', group=GRP_FLUX, inline='FLUX_MODE')
useModFlux        = input.bool(false, 'Î™®ÎîîÌååÏù¥Îìú ÌîåÎü≠Ïä§', group=GRP_FLUX, inline='FLUX_MODE')

momStyleInput     = input.string('KC', 'Î™®Î©òÌÖÄ Ïä§ÌÉÄÏùº', options=['KC', 'AVG', 'Deluxe', 'Mod'], group=GRP_CORE, inline='OSC_STYLE')
requireCross      = input.bool(true, 'Î™®Î©òÌÖÄ ÌÅ¨Î°úÏä§ ÌïÑÏàò', group=GRP_CORE, inline='MOM_FLAG')

useDynamicThresh  = input.bool(true, 'ÎèôÏ†Å ÏûÑÍ≥ÑÍ∞í', group=GRP_THRESH, inline='TH_MODE')
useSymThreshold   = input.bool(false, 'ÎåÄÏπ≠ Í≥†Ï†ï ÏûÑÍ≥ÑÍ∞í', group=GRP_THRESH, inline='TH_MODE')
statThreshold     = input.float(38.0, 'Ï†ïÏ†Å Í∏∞Ï§ÄÍ∞í', minval=0.0, group=GRP_THRESH, inline='TH_STAT')
buyThreshold      = input.float(36.0, 'Îß§Ïàò Í∏∞Ï§ÄÍ∞í', minval=0.0, group=GRP_THRESH, inline='TH_BOUNDS')
sellThreshold     = input.float(36.0, 'Îß§ÎèÑ Í∏∞Ï§ÄÍ∞í', minval=0.0, group=GRP_THRESH, inline='TH_BOUNDS')
dynLen            = input.int(21, 'ÎèôÏ†Å ÌëúÏ§ÄÌé∏Ï∞® Í∏∞Í∞Ñ', minval=1, group=GRP_THRESH, inline='TH_DYN')
dynMult           = input.float(1.1, 'ÎèôÏ†Å ÌëúÏ§ÄÌé∏Ï∞® Î∞∞Ïàò', minval=0.1, group=GRP_THRESH, inline='TH_DYN')

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// ÌïÑÌÑ∞ ÏûÖÎ†•
useAdx            = input.bool(false, 'ADX ÌïÑÌÑ∞', group=GRP_FILTER, inline='ADX_FLAG')
useAtrDiff        = input.bool(false, 'ATR Diff ÌïÑÌÑ∞', group=GRP_FILTER, inline='ADX_FLAG')
adxLen            = input.int(10, 'ADX Í∏∏Ïù¥', minval=1, group=GRP_FILTER, inline='ADX_CONF')
adxThresh         = input.float(15.0, 'ADX ÏûÑÍ≥ÑÍ∞í', minval=0.0, group=GRP_FILTER, inline='ADX_CONF')
adxAtrTf          = input.timeframe('5', 'ADX/ATR ÌÉÄÏûÑÌîÑÎ†àÏûÑ', group=GRP_FILTER, inline='ADX_TF')

useObv            = input.bool(false, 'OBV Í∏∞Ïö∏Í∏∞', group=GRP_FILTER, inline='OBV_FLAG')
obvSmoothLen      = input.int(3, 'OBV EMA Í∏∏Ïù¥', minval=1, group=GRP_FILTER, inline='OBV_FLAG')

useHtfTrend       = input.bool(false, 'ÏÉÅÏúÑÎ¥â Ï∂îÏÑ∏', group=GRP_FILTER, inline='HTF_FLAG')
htfTrendTf        = input.timeframe('240', 'ÏÉÅÏúÑÎ¥â TF', group=GRP_FILTER, inline='HTF_CONF')
htfMaLen          = input.int(20, 'ÏÉÅÏúÑÎ¥â EMA Í∏∏Ïù¥', minval=1, group=GRP_FILTER, inline='HTF_CONF')

useHmaFilter      = input.bool(false, 'HMA ÌïÑÌÑ∞', group=GRP_FILTER, inline='HMA_FLAG')
hmaLen            = input.int(20, 'HMA Í∏∏Ïù¥', minval=1, group=GRP_FILTER, inline='HMA_FLAG')

useRangeFilter    = input.bool(false, 'Î†àÏù∏ÏßÄ Î∞ïÏä§ ÌïÑÌÑ∞', group=GRP_FILTER, inline='RANGE_FLAG')
rangeTf           = input.timeframe('5', 'Î†àÏù∏ÏßÄ TF', group=GRP_FILTER, inline='RANGE_CONF')
rangeBars         = input.int(20, 'Î†àÏù∏ÏßÄ Î¥âÏàò', minval=1, group=GRP_FILTER, inline='RANGE_BOX')
rangePercent      = input.float(1.0, 'Î†àÏù∏ÏßÄ %', minval=0.0, group=GRP_FILTER, inline='RANGE_BOX')

useRegimeFilter   = input.bool(false, 'Î†àÏßê ÌïÑÌÑ∞', group=GRP_FILTER, inline='REGIME_FLAG')
ctxHtfTf          = input.timeframe('240', 'Î†àÏßê TF', group=GRP_FILTER, inline='REGIME_TF')
ctxHtfEmaLen      = input.int(120, 'Î†àÏßê EMA', minval=1, group=GRP_FILTER, inline='REGIME_EMA')
ctxHtfAdxLen      = input.int(14, 'Î†àÏßê ADX', minval=1, group=GRP_FILTER, inline='REGIME_ADX')
ctxHtfAdxTh       = input.float(22.0, 'Î†àÏßê ADX ÏûÑÍ≥Ñ', minval=0.0, group=GRP_FILTER, inline='REGIME_ADX')

useDistanceGuard  = input.bool(false, 'Ïù¥Í≤© Í∞ÄÎìú', group=GRP_FILTER, inline='DIST_FLAG')
distanceAtrLen    = input.int(21, 'ATR Í∏∏Ïù¥', minval=1, group=GRP_FILTER, inline='DIST_ATR')
distanceTrendLen  = input.int(55, 'Ï∂îÏÑ∏ EMA Í∏∏Ïù¥', minval=1, group=GRP_FILTER, inline='DIST_TREND')
distanceMaxAtr    = input.float(2.4, 'ÏµúÎåÄ ATR Î∞∞Ïàò', minval=0.1, group=GRP_FILTER, inline='DIST_TREND')

useDisparityGuard = input.bool(false, 'Disparity Index ÌïÑÌÑ∞', group=GRP_FILTER, inline='DISP_FLAG')
disparityLen      = input.int(34, 'Disparity Í∏∏Ïù¥', minval=1, group=GRP_FILTER, inline='DISP_CONF')
disparityMaxPct   = input.float(6.0, 'Disparity ÌïúÍ≥Ñ %', minval=0.0, group=GRP_FILTER, inline='DISP_CONF')

useSqzGate        = input.bool(false, 'Ïä§ÌÄ¥Ï¶à Í≤åÏù¥Ìä∏', group=GRP_FILTER, inline='SQZ_FLAG')
sqzReleaseBars    = input.int(5, 'Ïä§ÌÄ¥Ï¶à Ìï¥Ï†ú Ïú†ÏßÄ', minval=1, group=GRP_FILTER, inline='SQZ_FLAG')

useReversal       = input.bool(false, 'Î∞òÏ†Ñ ÏßÑÏûÖ', group=GRP_FILTER, inline='REV_FLAG')
reversalDelaySec  = input.float(0.0, 'Î∞òÏ†Ñ ÏßÄÏó∞(Ï¥à)', minval=0.0, group=GRP_FILTER, inline='REV_FLAG')

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Í∞ÄÎìú & Î¶¨Ïä§ÌÅ¨ ÏûÖÎ†•
leverage          = input.float(10.0, 'Î†àÎ≤ÑÎ¶¨ÏßÄ', minval=1.0, group=GRP_RISK, inline='RISK_BASE')
commissionPct     = input.float(0.05, 'ÏàòÏàòÎ£å %', minval=0.0, group=GRP_RISK, inline='RISK_BASE')
slipTicks         = input.int(1, 'Ïä¨Î¶¨ÌîºÏßÄ Ìã±', minval=0, group=GRP_RISK, inline='RISK_BASE2')
baseQtyPercent    = input.float(30.0, 'Í∏∞Î≥∏ Ìè¨ÏßÄÏÖò %', minval=0.0, group=GRP_RISK, inline='RISK_BASE2')
useSizingOverride = input.bool(false, 'Í≥†Í∏â ÏÇ¨Ïù¥Ïßï ÏÇ¨Ïö©', group=GRP_RISK, inline='SIZING_MODE')
sizingMode        = input.string('ÏûêÎ≥∏ ÎπÑÏú®', 'ÏÇ¨Ïù¥Ïßï Î™®Îìú', options=['ÏûêÎ≥∏ ÎπÑÏú®', 'Í≥†Ï†ï Í∏àÏï° (USD)', 'Í≥†Ï†ï Í≥ÑÏïΩ', 'Î¶¨Ïä§ÌÅ¨ Í∏∞Î∞ò'], group=GRP_RISK, inline='SIZING_MODE')
advancedPercent   = input.float(25.0, 'Í≥†Í∏â ÎπÑÏú® %', minval=0.0, group=GRP_RISK, inline='SIZ_ADV1')
fixedUsdAmount    = input.float(100.0, 'Í≥†Ï†ï USD', minval=0.0, group=GRP_RISK, inline='SIZ_ADV1')
fixedContractSize = input.float(1.0, 'Í≥†Ï†ï Í≥ÑÏïΩ ÏàòÎüâ', minval=0.0, group=GRP_RISK, inline='SIZ_ADV2')
riskSizingType    = input.string('ÏÜêÏ†à Í∏∞Î∞ò %', 'Î¶¨Ïä§ÌÅ¨ ÏÇ¨Ïù¥Ïßï ÌÉÄÏûÖ', options=['ÏÜêÏ†à Í∏∞Î∞ò %', 'Í≥†Ï†ï Í≥ÑÏïΩ'], group=GRP_RISK, inline='RISK_SIZE')
baseRiskPct       = input.float(0.6, 'Í∏∞Î≥∏ Î¶¨Ïä§ÌÅ¨ %', minval=0.0, group=GRP_RISK, inline='RISK_SIZE_VAL')
riskContractSize  = input.float(1.0, 'Î¶¨Ïä§ÌÅ¨ Í≥†Ï†ï Í≥ÑÏïΩ', minval=0.0, group=GRP_RISK, inline='RISK_SIZE_VAL')
useWallet         = input.bool(false, 'ÏõîÎ†õ ÏÇ¨Ïö©', group=GRP_RISK, inline='WALLET_FLAG')
profitReservePct  = input.float(20.0, 'Ï†ÅÎ¶Ω ÎπÑÏú® %', minval=0.0, maxval=100.0, group=GRP_RISK, inline='WALLET_CONF') * 0.01
applyReserveToSizing = input.bool(true, 'Ï†ÅÎ¶Ω Î∞òÏòÅ', group=GRP_RISK, inline='WALLET_CONF')
minTradableCapital = input.float(250.0, 'ÏµúÏÜå Í±∞Îûò ÏûêÎ≥∏', minval=0.0, group=GRP_RISK, inline='DRAWDOWN_BASE')
useDrawdownScaling = input.bool(false, 'ÎìúÎ°úÏö∞Îã§Ïö¥ Ï∂ïÏÜå', group=GRP_RISK, inline='DRAWDOWN_BASE')
drawdownTriggerPct = input.float(7.0, 'ÎìúÎ°úÏö∞Îã§Ïö¥ Ìä∏Î¶¨Í±∞ %', minval=0.0, group=GRP_RISK, inline='DRAWDOWN_CTRL')
drawdownRiskScale  = input.float(0.5, 'ÎìúÎ°úÏö∞Îã§Ïö¥ Î¶¨Ïä§ÌÅ¨ Î∞∞Ïú®', minval=0.0, group=GRP_RISK, inline='DRAWDOWN_CTRL')

usePerfAdaptiveRisk = input.bool(false, 'ÏÑ±Í≥º Ï†ÅÏùë Î¶¨Ïä§ÌÅ¨', group=GRP_RISK, inline='PAR_FLAG')
parLookback         = input.int(6, 'PAR Î£©Î∞± Í±∞Îûò Ïàò', minval=1, group=GRP_RISK, inline='PAR_FLAG')
parMinTrades        = input.int(3, 'PAR ÏµúÏÜå Í±∞Îûò', minval=1, group=GRP_RISK, inline='PAR_CORE')
parHotWinRate       = input.float(65.0, 'Ìï´ ÏäπÎ•† %', minval=0.0, maxval=100.0, group=GRP_RISK, inline='PAR_CORE')
parColdWinRate      = input.float(35.0, 'ÏΩúÎìú ÏäπÎ•† %', minval=0.0, maxval=100.0, group=GRP_RISK, inline='PAR_WIN')
parHotMult          = input.float(1.25, 'Ìï´ Î∞∞Ïú®', minval=0.0, group=GRP_RISK, inline='PAR_WIN')
parColdMult         = input.float(0.35, 'ÏΩúÎìú Î∞∞Ïú®', minval=0.0, group=GRP_RISK, inline='PAR_POST')
parPauseOnCold      = input.bool(true, 'ÏΩúÎìúÏãú Ï§ëÏßÄ', group=GRP_RISK, inline='PAR_POST')

startYear         = input.int(2024, 'ÏãúÏûë Ïó∞ÎèÑ', group=GRP_MISC, inline='START_DATE')
startMonth        = input.int(1, 'ÏãúÏûë Ïõî', group=GRP_MISC, inline='START_DATE')
startDay          = input.int(1, 'ÏãúÏûë Ïùº', group=GRP_MISC, inline='START_DATE')
startTime         = timestamp(syminfo.timezone, startYear, startMonth, startDay, 0, 0)

allowLongEntry    = input.bool(true, 'Î°± ÌóàÏö©', group=GRP_MISC, inline='ENTRY_FLAG')
allowShortEntry   = input.bool(true, 'Ïàè ÌóàÏö©', group=GRP_MISC, inline='ENTRY_FLAG')
reentryBars       = input.int(0, 'Ïû¨ÏßÑÏûÖ Ï†úÌïú Î¥âÏàò', minval=0, group=GRP_MISC, inline='ENTRY_CTRL')

debugForceLong    = input.bool(false, 'ÎîîÎ≤ÑÍ∑∏ Í∞ïÏ†ú Î°±', group=GRP_MISC, inline='DEBUG_FLAG')
debugForceShort   = input.bool(false, 'ÎîîÎ≤ÑÍ∑∏ Í∞ïÏ†ú Ïàè', group=GRP_MISC, inline='DEBUG_FLAG')

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Í∞ÄÎìú ÏûÖÎ†•
dailyLossGuard      = input.bool(false, 'ÏùºÏùº ÏÜêÏã§ Í∞ÄÎìú', group=GRP_GUARD, inline='DAILY_FLAG')
dailyLossLimit      = input.float(80.0, 'ÏùºÏùº ÏÜêÏã§ ÌïúÎèÑ', group=GRP_GUARD, inline='DAILY_FLAG')
dailyProfitLock     = input.bool(false, 'ÏùºÏùº Ïù¥Ïùµ Ïû†Í∏à', group=GRP_GUARD, inline='DAILY_PROF')
dailyProfitTarget   = input.float(120.0, 'ÏùºÏùº Ïù¥Ïùµ Î™©Ìëú', group=GRP_GUARD, inline='DAILY_PROF')
weeklyProfitLock    = input.bool(false, 'Ï£ºÍ∞Ñ Ïù¥Ïùµ Ïû†Í∏à', group=GRP_GUARD, inline='WEEKLY_FLAG')
weeklyProfitTarget  = input.float(250.0, 'Ï£ºÍ∞Ñ Ïù¥Ïùµ Î™©Ìëú', group=GRP_GUARD, inline='WEEKLY_FLAG')
lossStreakGuard     = input.bool(false, 'Ïó∞Ìå® Í∞ÄÎìú', group=GRP_GUARD, inline='STREAK_FLAG')
maxConsecutiveLoss  = input.int(3, 'ÏµúÎåÄ Ïó∞Ìå®', minval=0, group=GRP_GUARD, inline='STREAK_FLAG')
capitalGuard        = input.bool(false, 'ÏûêÎ≥∏ Í∞ÄÎìú', group=GRP_GUARD, inline='CAPITAL_FLAG')
capitalGuardPct     = input.float(20.0, 'ÏûêÎ≥∏ Í∞ÄÎìú %', minval=0.0, group=GRP_GUARD, inline='CAPITAL_FLAG')
maxDailyLosses      = input.int(0, 'ÏùºÏùº ÏµúÎåÄ ÏÜêÏã§ Í±∞Îûò', minval=0, group=GRP_GUARD, inline='LIMITS_COUNT')
maxWeeklyDD         = input.float(0.0, 'Ï£ºÍ∞Ñ ÏµúÎåÄ DD%', minval=0.0, group=GRP_GUARD, inline='LIMITS_DRAW')
maxGuardFires       = input.int(0, 'Í∞ÄÎìú ÏµúÎåÄ Î∞úÎèô', minval=0, group=GRP_GUARD, inline='LIMITS_DRAW')
useGuardExit        = input.bool(false, 'ÏÑ†Ï†ú Ï≤≠ÏÇ∞ Í∞ÄÎìú', group=GRP_GUARD, inline='PREEMPT_FLAG')
preemptTicks        = input.int(8, 'ÏÑ†Ï†ú Ìã±', minval=0, group=GRP_GUARD, inline='PREEMPT_FLAG')
liqBufferPctInput   = input.float(0.0, 'Ï≤≠ÏÇ∞ Î≤ÑÌçº %', minval=0.0, group=GRP_GUARD, inline='PREEMPT_BUF')

useVolatilityGuard  = input.bool(false, 'Î≥ÄÎèôÏÑ± Í∞ÄÎìú', group=GRP_GUARD, inline='VOL_FLAG')
volatilityLookback  = input.int(50, 'ATR% Î£©Î∞±', minval=1, group=GRP_GUARD, inline='VOL_FLAG')
volatilityLowerPct  = input.float(0.15, 'ATR% ÌïòÌïú', minval=0.0, group=GRP_GUARD, inline='VOL_RANGE')
volatilityUpperPct  = input.float(2.5, 'ATR% ÏÉÅÌïú', minval=0.0, group=GRP_GUARD, inline='VOL_RANGE')

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Ï∂úÍµ¨ ÏûÖÎ†•
exitOpposite      = input.bool(true, 'Î∞òÎåÄ Ïã†Ìò∏ Ï≤≠ÏÇ∞', group=GRP_EXIT, inline='EXIT_BASE')
useMomFade        = input.bool(false, 'Î™®Î©òÌÖÄ ÌéòÏù¥Îìú', group=GRP_EXIT, inline='EXIT_BASE')
momFadeBars       = input.int(1, 'ÌéòÏù¥Îìú ÏµúÏÜå Î¥â', minval=1, group=GRP_EXIT, inline='FADE_CORE')
momFadeRegLen     = input.int(20, 'ÌéòÏù¥Îìú ÌöåÍ∑Ä Í∏∏Ïù¥', minval=1, group=GRP_EXIT, inline='FADE_CORE')
momFadeBbLen      = input.int(20, 'ÌéòÏù¥Îìú BB Í∏∏Ïù¥', minval=1, group=GRP_EXIT, inline='FADE_BAND')
momFadeKcLen      = input.int(20, 'ÌéòÏù¥Îìú KC Í∏∏Ïù¥', minval=1, group=GRP_EXIT, inline='FADE_BAND')
momFadeBbMult     = input.float(2.0, 'ÌéòÏù¥Îìú BB Î∞∞Ïàò', minval=0.1, group=GRP_EXIT, inline='FADE_MULT')
momFadeKcMult     = input.float(1.5, 'ÌéòÏù¥Îìú KC Î∞∞Ïàò', minval=0.1, group=GRP_EXIT, inline='FADE_MULT')
momFadeUseTrueRange = input.bool(true, 'ÌéòÏù¥Îìú TR ÏÇ¨Ïö©', group=GRP_EXIT, inline='FADE_FLAG')
momFadeZeroDelay    = input.int(0, 'ÌéòÏù¥Îìú Ï†úÎ°ú ÎîúÎ†àÏù¥', minval=0, group=GRP_EXIT, inline='FADE_FLAG')
momFadeMinAbs       = input.float(0.0, 'ÌéòÏù¥Îìú ÏµúÏÜå Ï†àÎåÄÍ∞í', minval=0.0, group=GRP_EXIT, inline='FADE_FLAG2')
momFadeReleaseOnly  = input.bool(true, 'Ìï¥Ï†ú ÌõÑ ÌéòÏù¥Îìú', group=GRP_EXIT, inline='FADE_FLAG2')
momFadeMinBarsAfterRel = input.int(1, 'Ìï¥Ï†ú ÌõÑ ÏµúÏÜå Î¥â', minval=0, group=GRP_EXIT, inline='FADE_POST')
momFadeWindowBars   = input.int(6, 'ÌéòÏù¥Îìú ÏúàÎèÑÏö∞', minval=1, group=GRP_EXIT, inline='FADE_POST')
momFadeRequireTwo   = input.bool(false, '2Î¥â ÌôïÏù∏', group=GRP_EXIT, inline='FADE_POST')

useStopLoss       = input.bool(false, 'Í∏∞Î≥∏ ÏÜêÏ†à', group=GRP_EXIT, inline='STOP_BASE')
stopLookback      = input.int(5, 'Ïä§Ïúô ÏÜêÏ†à Î£©Î∞±', minval=1, group=GRP_EXIT, inline='STOP_BASE')
useAtrTrail       = input.bool(false, 'ATR Ìä∏Î†àÏùº', group=GRP_EXIT, inline='ATRL_BASE')
atrTrailLen       = input.int(7, 'ATR Ìä∏Î†àÏùº Í∏∏Ïù¥', minval=1, group=GRP_EXIT, inline='ATRL_BASE')
atrTrailMult      = input.float(2.5, 'ATR Ìä∏Î†àÏùº Î∞∞Ïàò', minval=0.0, group=GRP_EXIT, inline='ATRL_TUNE')
useBreakevenStop  = input.bool(false, 'Î∏åÎ†àÏù¥ÌÅ¨Ïù¥Î∏ê', group=GRP_EXIT, inline='BREAKEVEN_BASE')
breakevenMult     = input.float(1.0, 'Î∏åÎ†àÏù¥ÌÅ¨Ïù¥Î∏ê Î∞∞Ïàò', minval=0.0, group=GRP_EXIT, inline='BREAKEVEN_BASE')
useFixedStop      = input.bool(false, 'Í≥†Ï†ï ÏàòÏπò ÏÜêÏ†à ÏÇ¨Ïö©', group=GRP_EXIT, inline='FIXSTOP_FLAG')
fixedStopUseTicksLong  = input.bool(true, 'Î°± Ìã± Îã®ÏúÑ', group=GRP_EXIT, inline='FIXSTOP_LONG')
fixedStopValueLong     = input.float(20.0, 'Î°± ÏÜêÏ†à Í∞í', minval=0.0, group=GRP_EXIT, inline='FIXSTOP_LONG')
fixedStopUseTicksShort = input.bool(true, 'Ïàè Ìã± Îã®ÏúÑ', group=GRP_EXIT, inline='FIXSTOP_SHORT')
fixedStopValueShort    = input.float(20.0, 'Ïàè ÏÜêÏ†à Í∞í', minval=0.0, group=GRP_EXIT, inline='FIXSTOP_SHORT')
useAtrProfit      = input.bool(false, 'ATR Ïù¥Ïùµ Î™©Ìëú', group=GRP_EXIT, inline='ATR_PROFIT')
atrProfitMult     = input.float(2.0, 'ATR Ïù¥Ïùµ Î∞∞Ïàò', minval=0.0, group=GRP_EXIT, inline='ATR_PROFIT')
useDynVol         = input.bool(false, 'ÎèôÏ†Å Î≥ÄÎèô Î∞∞Ïú®', group=GRP_EXIT, inline='EXIT_GUARD')
useStopDistanceGuard = input.bool(false, 'ÏÜêÏ†à Í±∞Î¶¨ Í∞ÄÎìú', group=GRP_EXIT, inline='EXIT_GUARD')
maxStopAtrMult    = input.float(2.8, 'ÏµúÎåÄ ÏÜêÏ†à ATRÎ∞∞Ïàò', minval=0.0, group=GRP_EXIT, inline='EXIT_GUARD_VAL')
useTimeStop       = input.bool(false, 'ÏãúÍ∞Ñ ÏÜêÏ†à', group=GRP_EXIT, inline='HOLD_FLAG')
maxHoldBars       = input.int(45, 'ÏµúÎåÄ Î≥¥Ïú† Î¥â', minval=1, group=GRP_EXIT, inline='HOLD_CONF')
minHoldBarsInput  = input.int(0, 'ÏµúÏÜå Î≥¥Ïú† Î¥â', minval=0, group=GRP_EXIT, inline='HOLD_CONF')
useKasa           = input.bool(false, 'KASA RSI Ï∂úÍµ¨', group=GRP_EXIT, inline='KASA_FLAG')
kasaRsiLen        = input.int(14, 'KASA RSI Í∏∏Ïù¥', minval=1, group=GRP_EXIT, inline='KASA_FLAG')
kasaRsiOB         = input.float(72.0, 'KASA RSI OB', minval=0.0, maxval=100.0, group=GRP_EXIT, inline='KASA_RANGE')
kasaRsiOS         = input.float(28.0, 'KASA RSI OS', minval=0.0, maxval=100.0, group=GRP_EXIT, inline='KASA_RANGE')
useBeTiers        = input.bool(false, 'Î∏åÎ†àÏù¥ÌÅ¨Ïù¥Î∏ê Ìã∞Ïñ¥', group=GRP_EXIT, inline='KASA_EXTRA')

useShock          = input.bool(false, 'ÏáºÌÅ¨ Î™®Îìú', group=GRP_EXIT, inline='SHOCK_FLAG')
atrFastLen        = input.int(5, 'ÏáºÌÅ¨ ATR Îπ†Î•∏ÏÑ†', minval=1, group=GRP_EXIT, inline='SHOCK_FLAG')
atrSlowLen        = input.int(20, 'ÏáºÌÅ¨ ATR ÎäêÎ¶∞ÏÑ†', minval=1, group=GRP_EXIT, inline='SHOCK_CTRL')
shockMult         = input.float(2.5, 'ÏáºÌÅ¨ Î∞∞Ïàò', minval=0.0, group=GRP_EXIT, inline='SHOCK_CTRL')
shockAction       = input.string('ÏÜêÏ†à ÌÉÄÏù¥Ìä∏Îãù', 'ÏáºÌÅ¨ ÌñâÎèô', options=['ÏÜêÏ†à ÌÉÄÏù¥Ìä∏Îãù', 'Ï¶âÏãú Ï≤≠ÏÇ∞'], group=GRP_EXIT, inline='SHOCK_ACTION')

simpleMetricsOnly   = input.bool(false, 'Ïã¨Ìîå Î©îÌä∏Î¶≠ (Python)', group=GRP_MISC)

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// ÏãúÍ∞ÅÌôî & HUD ÏûÖÎ†•
showHudTable           = input.bool(true, 'ÏÉÅÌÉú HUD ÌëúÏãú', group=GRP_UI)
hudTablePositionInput  = input.string('Ïö∞ÏÉÅÎã®', 'ÏÉÅÌÉú HUD ÏúÑÏπò', options=['Ï¢åÏÉÅÎã®', 'Ïö∞ÏÉÅÎã®', 'Ï¢åÌïòÎã®', 'Ïö∞ÌïòÎã®'], group=GRP_UI)
hudTableTextSizeInput  = input.string('Î≥¥ÌÜµ', 'HUD Í∏ÄÏûê ÌÅ¨Í∏∞', options=['ÏûëÍ≤å', 'Î≥¥ÌÜµ', 'ÌÅ¨Í≤å'], group=GRP_UI)
showPriceHud           = input.bool(true, 'Í∞ÄÍ≤© HUD ÎùºÎ≤® ÌëúÏãú', group=GRP_UI)
priceHudAnchorInput    = input.string('ÏúÑÏ™Ω', 'Í∞ÄÍ≤© HUD Í∏∞Ï§Ä', options=['ÏúÑÏ™Ω', 'ÏïÑÎûòÏ™Ω'], group=GRP_UI)
priceHudAtrOffset      = input.float(1.0, 'Í∞ÄÍ≤© HUD ATR Î∞∞Ïàò', minval=0.0, step=0.25, group=GRP_UI)
hudBgColorInput        = input.color(color.new(color.black, 70), 'HUD Î∞∞Í≤ΩÏÉâ', group=GRP_UI)
hudTextColorInput      = input.color(color.white, 'HUD Í∏ÄÏûêÏÉâ', group=GRP_UI)
showSqueezeHighlight   = input.bool(true, 'Ïä§ÌÄ¥Ï¶à ÌïòÏù¥ÎùºÏù¥Ìä∏', group=GRP_UI)
showSignalMarkers      = input.bool(true, 'Ïã†Ìò∏ ÎßàÏª§ ÌëúÏãú', group=GRP_UI)
showMomentumDecorators = input.bool(true, 'Î™®Î©òÌÖÄ ÏûÑÍ≥ÑÍ∞í ÏãúÍ∞ÅÌôî', group=GRP_UI)

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// ÎÇ¥Î∂Ä Ïú†Ìã∏ Ìï®Ïàò (Python Ìó¨Ìçº Ìè¨ÌåÖ, v5 Í∑úÍ≤©)
clamp(x, lo, hi) =>
    x < lo ? lo : x > hi ? hi : x

nzf(value, replacement) =>
    na(value) ? replacement : value

maxIgnoreNaN(a, b) =>
    na(a) ? b : na(b) ? a : math.max(a, b)

minIgnoreNaN(a, b) =>
    na(a) ? b : na(b) ? a : math.min(a, b)

trueRange() =>
    math.max(math.max(high - low, math.abs(high - close[1])), math.abs(low - close[1]))

trueRangeHa() =>
    float prevHaClose = nz(haClose[1], haClose)
    math.max(math.max(haHigh - haLow, math.abs(haHigh - prevHaClose)), math.abs(haLow - prevHaClose))

boolText(flag) =>
    flag ? 'Ïòà' : 'ÏïÑÎãàÏò§'

atrSeries(len) =>
    ta.rma(trueRange(), len)

atrSeriesHa(len) =>
    ta.rma(trueRangeHa(), len)

stdSeries(src, len) =>
    ta.stdev(src, len)

disparityIndex(src, len) =>
    emaBase = ta.ema(src, len)
    diff    = ta.wma(math.abs(src - emaBase), len)
    denom   = math.abs(emaBase)
    denom == 0 or na(denom) ? 0.0 : diff / denom * 100.0

isHigherTimeframe(tf) =>
    tf != '' and timeframe.in_seconds(tf) > timeframe.in_seconds(timeframe.period)

// requestNoRepaint: (Ïù¥Ï†Ñ Î≤ÑÏ†Ñ Ìò∏ÌôòÏö©) ÌôïÏ†ïÎ¥â Í∞íÏúºÎ°ú Î≥¥Ï†ï
requestNoRepaint(tf, source) =>
    hasValidTf = tf != ''
    resolvedTf = hasValidTf ? tf : timeframe.period
    secSeries = request.security(syminfo.tickerid, resolvedTf, source, lookahead=barmerge.lookahead_off, gaps=barmerge.gaps_off)
    if hasValidTf and isHigherTimeframe(resolvedTf)
        nz(secSeries[1], secSeries)
    else
        secSeries

securitySeries(tf, source) =>
    requestNoRepaint(tf, source)

resolveTablePosition(posStr) =>
    switch posStr
        'Ï¢åÏÉÅÎã®' => position.top_left
        'Ï¢åÌïòÎã®' => position.bottom_left
        'Ïö∞ÌïòÎã®' => position.bottom_right
        => position.top_right

resolveTextSize(sizeStr) =>
    sizeStr == 'ÏûëÍ≤å' ? size.small : sizeStr == 'ÌÅ¨Í≤å' ? size.large : size.normal

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Heikin-Ashi Î°úÏª¨ Í≥ÑÏÇ∞ (security() ÎØ∏ÏÇ¨Ïö©: Í≤ΩÍ≥† Í∞êÏÜå)
var float haOpen = na
haClose = (open + high + low + close) / 4.0
haOpen  := na(haOpen[1]) ? (open + close) / 2.0 : (haOpen[1] + haClose[1]) / 2.0
haHigh  = math.max(high, math.max(haOpen, haClose))
haLow   = math.min(low,  math.min(haOpen, haClose))

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// ‚úÖ [ÏàòÏ†ïÎê®] HTF ÏïàÏ†Ñ ÎûòÌçº: request.security ÏóêÎü¨Î•º Ìï¥Í≤∞ÌïòÍ∏∞ ÏúÑÌï¥ Íµ¨Ï°∞ Î≥ÄÍ≤Ω
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// ‚úÖ [ÏµúÏ¢Ö ÏàòÏ†ï] HTF ÏïàÏ†Ñ ÎûòÌçº: request.securityÍ∞Ä Ï°∞Í±¥Î¨∏ ÎÇ¥Î∂ÄÏóê ÏûàÏßÄ ÏïäÎèÑÎ°ù Íµ¨Ï°∞ Î≥ÄÍ≤Ω
f_htf(tf, indicatorType, len) =>
    // 1. Ïñ¥Îñ§ Îç∞Ïù¥ÌÑ∞Î•º Í≥ÑÏÇ∞Ìï†ÏßÄ Î®ºÏ†Ä Í≤∞Ï†ï (Ïù¥ Î∂ÄÎ∂ÑÏùÄ Ï°∞Í±¥Î¨∏ ÏïàÏóê ÏûàÏñ¥ÎèÑ OK)
    float src_series = switch indicatorType
        'dmi_adx' =>
            [_, _, adx] = ta.dmi(len, len)
            adx
        'atr' => atrSeries(len)
        'ema' => ta.ema(close, len)
        'highest' => ta.highest(high, len)
        'lowest' => ta.lowest(low, len)
        'close' => close
        => na

    // 2. request.securityÎ•º Ï°∞Í±¥Î¨∏ Î∞ñÏóêÏÑú "Î¨¥Ï°∞Í±¥" Ìò∏Ï∂ú
    // ÎßåÏïΩ tfÍ∞Ä ÎπÑÏñ¥ÏûàÏúºÎ©¥ ÏóêÎü¨Í∞Ä ÎÇòÎØÄÎ°ú, ÌòÑÏû¨ ÌÉÄÏûÑÌîÑÎ†àÏûÑÏúºÎ°ú ÎåÄÏ≤¥Ìï¥ÏÑú ÏïàÏ†ÑÌïòÍ≤å Ìò∏Ï∂ú
    string safe_tf = tf == '' ? timeframe.period : tf
    // lookahead=barmerge.lookahead_offÎ•º ÏÇ¨Ïö©ÌïòÎØÄÎ°ú, ÏÉÅÏúÑ Î¥âÏù¥ ÌôïÏ†ïÎêú Í∞íÎßå Î∞òÌôòÎê©ÎãàÎã§.
    htf_series = request.security(syminfo.tickerid, safe_tf, src_series, lookahead=barmerge.lookahead_off, gaps=barmerge.gaps_off)

    // 3. Ïù¥Ï†ú Ï°∞Í±¥Ïóê Îî∞Îùº Ïñ¥Îñ§ Í∞íÏùÑ "Î∞òÌôò"Ìï†ÏßÄ Í≤∞Ï†ï
    // ÏÉÅÏúÑ ÌÉÄÏûÑÌîÑÎ†àÏûÑÏù¥ Ïú†Ìö®Ìï† ÎïåÎßå security Í≤∞Í≥ºÍ∞íÏùÑ ÏÇ¨Ïö©ÌïòÍ≥†, ÏïÑÎãê Í≤ΩÏö∞ ÌòÑÏû¨ Î¥âÏùò Í≥ÑÏÇ∞Í∞íÏùÑ ÏÇ¨Ïö©
    bool useHtf = tf != '' and isHigherTimeframe(safe_tf)

    // üìå Ïã§ÏãúÍ∞Ñ(barstate.isrealtime)ÏóêÏÑú ÏÉÅÏúÑ ÌÉÄÏûÑÌîÑÎ†àÏûÑ Í∞íÏùÄ ÏïÑÏßÅ ÌôïÏ†ïÎêòÏßÄ ÏïäÏùÄ Í∞íÏù¥ Îì§Ïñ¥ÏôÄ Í≤ΩÍ≥†Ïùò ÏõêÏù∏Ïù¥ ÎêúÎã§.
    //    Ïã§ÏãúÍ∞Ñ Íµ¨Í∞ÑÏóêÏÑúÎäî Ïù¥Ï†Ñ ÌôïÏ†ï Í∞í(htf_series[1])ÏùÑ ÏÇ¨Ïö©ÌïòÍ≥†, ÌûàÏä§ÌÜ†Î¶¨/ÌôïÏ†ï Íµ¨Í∞ÑÏóêÏÑúÎäî ÏµúÏã† Í∞íÏùÑ ÏÇ¨Ïö©Ìï¥ ÏßÄÏó∞ÏùÑ ÏµúÏÜåÌôîÌïúÎã§.
    float confirmedHtf = htf_series
    if useHtf
        float fallbackHtf = nz(htf_series[1], src_series)
        confirmedHtf := barstate.isrealtime ? fallbackHtf : htf_series

    final_series = useHtf ? confirmedHtf : src_series
    final_series

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// ÌîåÎü≠Ïä§ ÏßÄÌëúÎì§ (HAÎäî Î°úÏª¨ ÏãúÎ¶¨Ï¶à ÌôúÏö©)
directionalFlux(useHa, len, smoothLen) =>
    srcH = useHa ? haHigh : high
    srcL = useHa ? haLow  : low
    upMove  = math.max(srcH - nz(srcH[1]), 0)
    dnMove  = math.max(nz(srcL[1]) - srcL, 0)
    tr      = useHa ? atrSeriesHa(len) : atrSeries(len)
    up      = tr != 0 ? ta.rma(upMove, len) / tr : 0
    dn      = tr != 0 ? ta.rma(dnMove, len) / tr : 0
    denom   = up + dn
    ratio   = denom != 0 ? (up - dn) / denom : 0
    core    = ta.rma(ratio, math.max(math.round(len / 2.0), 1)) * 100
    smoothLen > 1 ? ta.sma(core, smoothLen) : core

modDirectionalFlux(useHa, len, smoothLen) =>
    srcH = useHa ? haHigh : high
    srcL = useHa ? haLow : low
    upMove  = math.max(srcH - nz(srcH[1]), 0)
    dnMove  = math.max(nz(srcL[1]) - srcL, 0)
    plusDM  = upMove > dnMove and upMove > 0 ? upMove : 0
    minusDM = dnMove > upMove and dnMove > 0 ? dnMove : 0
    plusR   = ta.rma(plusDM, len)
    minusR  = ta.rma(minusDM, len)
    tr      = useHa ? atrSeriesHa(len) : atrSeries(len)
    up      = tr != 0 ? plusR / tr : 0
    dn      = tr != 0 ? minusR / tr : 0
    denom   = up + dn
    ratio   = denom != 0 ? (up - dn) / denom : 0
    core    = ta.rma(ratio, math.max(math.round(len / 2.0), 1)) * 100
    smoothLen > 1 ? ta.sma(core, smoothLen) : core

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Í∏∞Î≥∏ ÌååÏÉùÍ∞í Í≥ÑÏÇ∞
bbLenEff = useSameLen ? oscLen : bbLen
kcLenEff = useSameLen ? oscLen : kcLen
tickSize = syminfo.mintick
slipValue = tickSize * slipTicks
fixedStopOffsetLong  = useFixedStop ? (fixedStopUseTicksLong ? fixedStopValueLong * tickSize : fixedStopValueLong) : 0.0
fixedStopOffsetShort = useFixedStop ? (fixedStopUseTicksShort ? fixedStopValueShort * tickSize : fixedStopValueShort) : 0.0

calcFixedStopPriceLong(entryPrice) =>
    useFixedStop and fixedStopOffsetLong > 0 ? math.max(entryPrice - fixedStopOffsetLong, tickSize) : na

calcFixedStopPriceShort(entryPrice) =>
    useFixedStop and fixedStopOffsetShort > 0 ? entryPrice + fixedStopOffsetShort : na

calcProspectiveStopLong(entryPrice, atrTrailSeries, dynFactor, swingLowForStop) =>
    float stop = na
    if useAtrTrail and not na(atrTrailSeries)
        stop := maxIgnoreNaN(stop, entryPrice - atrTrailSeries * atrTrailMult * dynFactor)
    if useStopLoss
        if not na(swingLowForStop) and swingLowForStop < entryPrice
            stop := maxIgnoreNaN(stop, swingLowForStop)
    float fsLong = calcFixedStopPriceLong(entryPrice)
    if not na(fsLong)
        stop := maxIgnoreNaN(stop, fsLong)
    if not na(stop)
        float cap = entryPrice - tickSize
        if cap > tickSize
            stop := math.min(stop, cap)
        stop := math.max(stop, tickSize)
    stop

calcProspectiveStopShort(entryPrice, atrTrailSeries, dynFactor, swingHighForStop) =>
    float stop = na
    if useAtrTrail and not na(atrTrailSeries)
        stop := minIgnoreNaN(stop, entryPrice + atrTrailSeries * atrTrailMult * dynFactor)
    if useStopLoss
        if not na(swingHighForStop) and swingHighForStop > entryPrice
            stop := minIgnoreNaN(stop, swingHighForStop)
    float fsShort = calcFixedStopPriceShort(entryPrice)
    if not na(fsShort)
        stop := minIgnoreNaN(stop, fsShort)
    if not na(stop)
        float cap = entryPrice + tickSize
        stop := math.max(stop, cap)
    stop

atrPrimary = atrSeries(kcLenEff)
atrOsc = atrSeries(oscLen)

hl2x = (high + low) / 2.0
highestHigh = ta.highest(high, kcLenEff)
lowestLow = ta.lowest(low, kcLenEff)
meanKc = (highestHigh + lowestLow) / 2.0
bbBasisClose = ta.sma(close, bbLenEff)
kcBasis = ta.sma(hl2x, kcLenEff)
kcRangeSeries = atrPrimary * kcMult
kcUpper = kcBasis + kcRangeSeries
kcLower = kcBasis - kcRangeSeries
kcAverage = (kcUpper + kcLower) / 2.0
midline = (hl2x + kcAverage) / 2.0
avgLineAvg = (bbBasisClose + meanKc) / 2.0
bbMidHl2 = ta.sma(hl2x, bbLenEff)
avgLineDeluxe = (meanKc + bbMidHl2) / 2.0

momStyle = switch str.lower(momStyleInput)
    'avg' => 'avg'
    'deluxe' => 'deluxe'
    'mod' => 'mod'
    => 'kc'

// ‚úÖ [2025-02-15] ATR Ï†ïÍ∑úÌôî Ï°∞Í±¥ Ïû¨Ï°∞Ï†ï: 'avg'ÏôÄ 'mod'Îßå ATRÎ°ú ÎÇòÎàÑÍ≥† ÎÇòÎ®∏ÏßÄÎäî ÏõêÏãú Ï∞®Ïù¥Í∞íÏùÑ ÏÇ¨Ïö©
normRaw = switch momStyle
    'avg'    => (close - avgLineAvg) / nz(atrPrimary, 1)
    'deluxe' => (close - avgLineDeluxe)
    'mod'    => (close - midline) / nz(atrPrimary, 1)
    => (close - meanKc)

normSeries = nz(normRaw) * 100.0
momentum = ta.linreg(normSeries, oscLen, 0)
momSignal = switch str.lower(maTypeInput)
    'ema' => ta.ema(momentum, signalLen)
    'hma' => ta.hma(momentum, signalLen)
    => ta.sma(momentum, signalLen)

crossUp = ta.crossover(momentum, momSignal)
crossDown = ta.crossunder(momentum, momSignal)

float fluxHist = na
if useModFlux
    fluxHist := modDirectionalFlux(useFluxHeikin, fluxLen, fluxSmoothLen)
else
    directionalFluxResult = directionalFlux(useFluxHeikin, fluxLen, fluxSmoothLen)
    fluxHist := fluxSmoothLen > 1 ? ta.sma(directionalFluxResult, fluxSmoothLen) : directionalFluxResult

momFadeSource = (high + low + close) / 3.0
momFadeBasis = ta.sma(momFadeSource, momFadeBbLen)
momFadeTr = momFadeUseTrueRange ? ta.rma(trueRange(), momFadeKcLen) : ta.sma(math.abs(high - low), momFadeKcLen)
momFadeHist = ta.linreg(momFadeSource - momFadeBasis, momFadeRegLen, 0)
momFadeAbs = math.abs(momFadeHist)

bbDev = stdSeries(close, bbLenEff) * bbMult
gateSqOn = bbDev < kcRangeSeries ? 1 : 0
gateSqPrev = gateSqOn[1] == 1
gateSqRelease = gateSqPrev and gateSqOn == 0
var int gateRelCounter = na
if gateSqRelease
    gateRelCounter := 0
else if not na(gateRelCounter)
    gateRelCounter += 1

var float buyThresh = na
var float sellThresh = na
if useDynamicThresh
    dynStd = ta.stdev(momentum, dynLen) * dynMult
    fallback = statThreshold != 0 ? math.abs(statThreshold) : nz(ta.sma(dynStd, dynLen), 1.0)
    dynStd := na(dynStd) or dynStd == 0 ? fallback : math.abs(dynStd)
    buyThresh := -dynStd
    sellThresh := dynStd
else
    if useSymThreshold
        buyThresh := -math.abs(statThreshold)
        sellThresh := math.abs(statThreshold)
    else
        buyThresh := -math.abs(buyThreshold)
        sellThresh := math.abs(sellThreshold)

float volGuardAtrPct = na
if useVolatilityGuard
    atrVal = atrSeries(volatilityLookback)
    volGuardAtrPct := atrVal / close * 100

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// ‚úÖ [ÏàòÏ†ïÎê®] HTF ÏãúÎ¶¨Ï¶à: ÏàòÏ†ïÌïú f_htf Ìï®Ïàò Ìò∏Ï∂ú Î∞©ÏãùÏúºÎ°ú Î≥ÄÍ≤Ω
adxHtfSeries = f_htf(adxAtrTf, 'dmi_adx', adxLen)
atrHtfSeries = f_htf(adxAtrTf, 'atr', adxLen)

float adxSeries = 0.0
float atrDiff = 0.0
if useAdx or useAtrDiff
    adxSeries := nz(adxHtfSeries)
    if useAtrDiff
        atrDiff := nz(atrHtfSeries - ta.sma(atrHtfSeries, adxLen))

var float obvAccum = 0.0
float obvSlopeVal = 0.0
if useObv
    direction = math.sign(close - close[1])
    obvAccum := nz(obvAccum[1]) + direction * nz(volume, 0)
    obvSlopeVal := ta.ema(ta.change(obvAccum), math.max(obvSmoothLen, 1))

htfMaSeries = f_htf(htfTrendTf, 'ema', htfMaLen)
htfMa = useHtfTrend ? htfMaSeries : close
htfTrendUp = not useHtfTrend or (close > htfMa)
htfTrendDown = not useHtfTrend or (close < htfMa)

hmaValue = useHmaFilter ? ta.hma(close, hmaLen) : close

rangeHighSeries = f_htf(rangeTf, 'highest', rangeBars)
rangeLowSeries  = f_htf(rangeTf, 'lowest', rangeBars)
inRangeBox = false
if useRangeFilter
    rangeHighVal = rangeHighSeries
    rangeLowVal  = rangeLowSeries
    inRangeBox   := not na(rangeHighVal) and not na(rangeLowVal) and rangeLowVal != 0 ? ((rangeHighVal - rangeLowVal) / math.abs(rangeLowVal) * 100) <= rangePercent : false

disparityPct = useDisparityGuard ? disparityIndex(close, disparityLen) : 0.0
disparityOk = not useDisparityGuard or disparityPct <= disparityMaxPct

kasaRsiVal = useKasa ? ta.rsi(close, kasaRsiLen) : 50

// ‚úÖ [ÏàòÏ†ïÎê®] Î†àÏßê ÌïÑÌÑ∞Ïö© ÏÉÅÏúÑ ÌÉÄÏûÑÌîÑÎ†àÏûÑ Ìò∏Ï∂ú Î∞©Ïãù Î≥ÄÍ≤Ω
ctxCloseSeries = f_htf(ctxHtfTf, 'close', 0) // Í∏∏Ïù¥Îäî Î∂àÌïÑÏöîÌïòÎØÄÎ°ú 0
ctxEmaSeries   = f_htf(ctxHtfTf, 'ema', ctxHtfEmaLen)
ctxAdxSeries   = f_htf(ctxHtfTf, 'dmi_adx', ctxHtfAdxLen)
regimeLongOk = true
regimeShortOk = true
if useRegimeFilter
    regimeLongOk  := not na(ctxCloseSeries) and not na(ctxEmaSeries) and not na(ctxAdxSeries) and (ctxCloseSeries > ctxEmaSeries and ctxAdxSeries > ctxHtfAdxTh)
    regimeShortOk := not na(ctxCloseSeries) and not na(ctxEmaSeries) and not na(ctxAdxSeries) and (ctxCloseSeries < ctxEmaSeries and ctxAdxSeries > ctxHtfAdxTh)

gateSqValid = not useSqzGate ? true : (not na(gateRelCounter) and gateRelCounter <= sqzReleaseBars and gateSqOn == 0)

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// ÏÉÅÌÉú Î≥ÄÏàò Ï¥àÍ∏∞Ìôî
var bool guardFrozen = false
var int guardFiredTotal = 0
var int lossStreak = 0
var int dailyLosses = 0
var int reentryCountdown = 0
var int reversalCountdown = 0
var int lastDir = 0
var float tradableCapital = strategy.initial_capital
var float peakEquity = strategy.initial_capital
var float dailyStartCapital = strategy.initial_capital
var float dailyPeakCapital = strategy.initial_capital
var float weekStartEquity = strategy.initial_capital
var float weekPeakEquity = strategy.initial_capital
var float withdrawable = 0.0
var float lastEntryPrice = na
var float lastEntryQty = 0.0
var int lastPositionDir = 0
var float highestSinceEntry = na
var float lowestSinceEntry = na
var float fixedStopPriceLong = na
var float fixedStopPriceShort = na
var int barsHeld = 0
var float liqBufferPct = liqBufferPctInput * 0.01
var array<float> recentPnls = array.new_float()
var table statusTable = na
var string statusTablePosCache = ''
var label priceHudLabel = na

newDay = dayofmonth != dayofmonth[1]
newWeek = weekofyear != weekofyear[1]

if barstate.isconfirmed
    profitDelta = strategy.netprofit - nz(strategy.netprofit[1])
    if useWallet and profitDelta > 0
        withdrawable += profitDelta * profitReservePct

equity = strategy.equity
effectiveEquity = useWallet and applyReserveToSizing ? equity - withdrawable : equity
tradableCapital := math.max(effectiveEquity, strategy.initial_capital * 0.01)

peakEquity := math.max(peakEquity, equity)
dailyPeakCapital := math.max(dailyPeakCapital, tradableCapital)
weekPeakEquity := math.max(weekPeakEquity, equity)

if newDay
    dailyStartCapital := tradableCapital
    dailyPeakCapital := tradableCapital
    dailyLosses := 0
    guardFrozen := false
if newWeek
    weekStartEquity := equity
    weekPeakEquity := equity

dailyPnl = tradableCapital - dailyStartCapital
weeklyPnl = equity - weekStartEquity
weeklyDD = weekPeakEquity > 0 ? (weekPeakEquity - equity) / weekPeakEquity * 100 : 0
totalWithdrawable = math.max(useWallet ? withdrawable : strategy.netprofit, 0.0)

dailyLossBreached = dailyLossGuard and dailyPnl <= -math.abs(dailyLossLimit)
dailyProfitReached = dailyProfitLock and dailyPnl >= math.abs(dailyProfitTarget)
weeklyProfitReached = weeklyProfitLock and weeklyPnl >= math.abs(weeklyProfitTarget)
lossStreakBreached = lossStreakGuard and lossStreak >= maxConsecutiveLoss
capitalBreached = capitalGuard and equity <= strategy.initial_capital * (1 - capitalGuardPct / 100.0)
weeklyDdBreached = maxWeeklyDD > 0 and weeklyDD >= maxWeeklyDD
lossCountBreached = maxDailyLosses > 0 and dailyLosses >= maxDailyLosses
guardFireLimit = maxGuardFires > 0 and guardFiredTotal >= maxGuardFires
atrPctVal = useVolatilityGuard ? nz(volGuardAtrPct, 0) : 0
volatilityOk = not useVolatilityGuard or (atrPctVal >= volatilityLowerPct and atrPctVal <= volatilityUpperPct)

performancePause = false
if usePerfAdaptiveRisk and array.size(recentPnls) >= parMinTrades
    wins = 0
    for i = 0 to array.size(recentPnls) - 1
        if array.get(recentPnls, i) > 0
            wins += 1
    winRate = array.size(recentPnls) > 0 ? wins / array.size(recentPnls) * 100 : 0
    if winRate <= parColdWinRate and parPauseOnCold
        performancePause := true

performancePauseActivated = performancePause and not nz(performancePause[1], false)

shouldFreeze = dailyLossBreached or dailyProfitReached or weeklyProfitReached or lossStreakBreached or capitalBreached or weeklyDdBreached or lossCountBreached or guardFireLimit or performancePause or tradableCapital < minTradableCapital
wasFrozen = guardFrozen
if shouldFreeze
    guardFrozen := true

guardActivated = guardFrozen and not wasFrozen
if guardActivated and strategy.position_size != 0
    lastDir := strategy.position_size > 0 ? 1 : -1
    strategy.close('Ìè¨ÏßÄÏÖò', comment='Guard Halt')
    guardFiredTotal += 1

alertcondition(guardActivated, title='Î¶¨Ïä§ÌÅ¨ Í∞ÄÎìú Î∞úÎèô', message='Îß§ÏßÅ1Î∂ÑVN: Í∞ÄÎìú Î∞úÎèôÏúºÎ°ú Í±∞Îûò Ï§ëÏßÄ')
alertcondition(performancePauseActivated, title='ÏÑ±Í≥º Í∏∞Î∞ò Ï§ëÏßÄ', message='Îß§ÏßÅ1Î∂ÑVN: ÏÑ±Í≥º Í∏∞Î∞ò Í±∞Îûò ÏùºÏãú Ï§ëÏßÄ')

if useGuardExit and strategy.position_size != 0 and not guardActivated
    entryP = strategy.position_avg_price
    leveragePct = leverage > 0 ? 1.0 / leverage : 0.0
    if entryP > 0 and leveragePct > 0
        priceOffset = entryP * leveragePct
        liqPrice = strategy.position_size > 0 ? entryP - priceOffset : entryP + priceOffset
        if liqBufferPct > 0
            buffer = entryP * liqBufferPct
            liqPrice += strategy.position_size > 0 ? -buffer : buffer
        liqPrice := strategy.position_size > 0 ? math.max(liqPrice, tickSize) : liqPrice
        preemptPrice = strategy.position_size > 0 ? liqPrice + preemptTicks * tickSize : liqPrice - preemptTicks * tickSize
        hitGuard = strategy.position_size > 0 ? low <= preemptPrice : high >= preemptPrice
        if hitGuard
            lastDir := strategy.position_size > 0 ? 1 : -1
            strategy.close('Ìè¨ÏßÄÏÖò', comment='Guard Exit')
            guardFrozen := true
            guardFiredTotal += 1

canTrade = not guardFrozen and volatilityOk
if time < startTime
    canTrade := false

if reentryCountdown > 0 and strategy.position_size == 0
    reentryCountdown -= 1
if reversalCountdown > 0 and strategy.position_size == 0
    reversalCountdown -= 1

if barstate.islast
    if showHudTable
        hudPosition = resolveTablePosition(hudTablePositionInput)
        if statusTablePosCache != hudTablePositionInput or na(statusTable)
            if not na(statusTable)
                table.delete(statusTable)
            statusTable := table.new(hudPosition, 2, 11, border_width=1)
        statusTablePosCache := hudTablePositionInput

        hudTextSize = resolveTextSize(hudTableTextSizeInput)
        hudHeaderSize = hudTableTextSizeInput == 'ÏûëÍ≤å' ? size.normal : hudTableTextSizeInput == 'ÌÅ¨Í≤å' ? size.huge : size.large

        headerBg = color.new(hudBgColorInput, 0)
        labelBg = color.new(hudBgColorInput, 35)
        neutralBg = color.new(color.gray, 85)

        capColor = tradableCapital < minTradableCapital or guardFrozen ? color.new(color.red, 55) : color.new(color.green, 65)
        dailyColor = dailyPnl > 0 ? color.new(color.green, 60) : dailyPnl < 0 ? color.new(color.red, 55) : neutralBg
        withdrawColor = totalWithdrawable > 0 ? color.new(color.green, 60) : totalWithdrawable < 0 ? color.new(color.red, 55) : neutralBg
        weeklyColor = weeklyPnl > 0 ? color.new(color.green, 60) : weeklyPnl < 0 ? color.new(color.red, 55) : neutralBg
        lossColor = lossStreak > 0 ? color.new(color.orange, 55) : color.new(color.green, 65)
        guardColor = guardFrozen ? color.new(color.red, 55) : color.new(color.green, 60)
        volColor = volatilityOk ? color.new(color.green, 60) : color.new(color.red, 55)
        perfColor = performancePause ? color.new(color.orange, 55) : color.new(color.green, 60)
        squeezeStateText = gateSqOn == 1 ? 'ÏïïÏ∂ï ÏßÑÌñâ' : gateSqRelease ? 'Ìï¥Ï†ú Ïã†Ìò∏' : 'ÎåÄÍ∏∞'
        squeezeColor = gateSqOn == 1 ? color.new(color.blue, 70) : gateSqRelease ? color.new(color.purple, 65) : neutralBg
        roundedBuy = math.round(buyThresh * 100.0) / 100.0
        roundedSell = math.round(sellThresh * 100.0) / 100.0
        roundedMomentum = math.round(momentum * 100.0) / 100.0
        thresholdInfo = 'Îß§Ïàò ' + str.tostring(roundedBuy) + ' / Îß§ÎèÑ ' + str.tostring(roundedSell) + '\nÎ™®Î©òÌÖÄ ' + str.tostring(roundedMomentum)

        table.cell(statusTable, 0, 0, 'üìä Îß§ÏßÅ1Î∂ÑVN ÏÉÅÌÉú HUD', text_color=hudTextColorInput, text_size=hudHeaderSize)
        table.cell(statusTable, 1, 0, '', text_color=hudTextColorInput)
        table.merge_cells(statusTable, 0, 0, 1, 0)
        table.cell_set_bgcolor(statusTable, 0, 0, headerBg)
        table.cell_set_bgcolor(statusTable, 1, 0, headerBg)

        table.cell(statusTable, 0, 1, 'Í±∞Îûò Í∞ÄÎä• ÏûêÎ≥∏', text_color=hudTextColorInput, text_size=hudTextSize)
        table.cell_set_bgcolor(statusTable, 0, 1, labelBg)
        table.cell(statusTable, 1, 1, str.tostring(tradableCapital, format.mintick), text_color=hudTextColorInput, text_size=hudTextSize)
        table.cell_set_bgcolor(statusTable, 1, 1, capColor)

        table.cell(statusTable, 0, 2, 'Ï∂úÍ∏à Í∞ÄÎä• Í∏àÏï°', text_color=hudTextColorInput, text_size=hudTextSize)
        table.cell_set_bgcolor(statusTable, 0, 2, labelBg)
        table.cell(statusTable, 1, 2, str.tostring(totalWithdrawable, format.mintick), text_color=hudTextColorInput, text_size=hudTextSize)
        table.cell_set_bgcolor(statusTable, 1, 2, withdrawColor)

        table.cell(statusTable, 0, 3, 'Ïùº ÏÜêÏùµ', text_color=hudTextColorInput, text_size=hudTextSize)
        table.cell_set_bgcolor(statusTable, 0, 3, labelBg)
        table.cell(statusTable, 1, 3, str.tostring(dailyPnl, format.mintick), text_color=hudTextColorInput, text_size=hudTextSize)
        table.cell_set_bgcolor(statusTable, 1, 3, dailyColor)

        table.cell(statusTable, 0, 4, 'Ï£ºÍ∞Ñ ÏÜêÏùµ', text_color=hudTextColorInput, text_size=hudTextSize)
        table.cell_set_bgcolor(statusTable, 0, 4, labelBg)
        table.cell(statusTable, 1, 4, str.tostring(weeklyPnl, format.mintick), text_color=hudTextColorInput, text_size=hudTextSize)
        table.cell_set_bgcolor(statusTable, 1, 4, weeklyColor)

        table.cell(statusTable, 0, 5, 'Ïó∞ÏÜç ÏÜêÏã§', text_color=hudTextColorInput, text_size=hudTextSize)
        table.cell_set_bgcolor(statusTable, 0, 5, labelBg)
        table.cell(statusTable, 1, 5, str.tostring(lossStreak), text_color=hudTextColorInput, text_size=hudTextSize)
        table.cell_set_bgcolor(statusTable, 1, 5, lossColor)

        table.cell(statusTable, 0, 6, 'Í∞ÄÎìú ÏÉÅÌÉú', text_color=hudTextColorInput, text_size=hudTextSize)
        table.cell_set_bgcolor(statusTable, 0, 6, labelBg)
        table.cell(statusTable, 1, 6, boolText(guardFrozen), text_color=hudTextColorInput, text_size=hudTextSize)
        table.cell_set_bgcolor(statusTable, 1, 6, guardColor)

        table.cell(statusTable, 0, 7, 'Î≥ÄÎèôÏÑ± Ï°∞Í±¥', text_color=hudTextColorInput, text_size=hudTextSize)
        table.cell_set_bgcolor(statusTable, 0, 7, labelBg)
        table.cell(statusTable, 1, 7, boolText(volatilityOk), text_color=hudTextColorInput, text_size=hudTextSize)
        table.cell_set_bgcolor(statusTable, 1, 7, volColor)

        table.cell(statusTable, 0, 8, 'ÏÑ±Í≥º Ï§ëÏßÄ', text_color=hudTextColorInput, text_size=hudTextSize)
        table.cell_set_bgcolor(statusTable, 0, 8, labelBg)
        table.cell(statusTable, 1, 8, boolText(performancePause), text_color=hudTextColorInput, text_size=hudTextSize)
        table.cell_set_bgcolor(statusTable, 1, 8, perfColor)

        table.cell(statusTable, 0, 9, 'Ïä§ÌÄ¥Ï¶à', text_color=hudTextColorInput, text_size=hudTextSize)
        table.cell_set_bgcolor(statusTable, 0, 9, labelBg)
        table.cell(statusTable, 1, 9, squeezeStateText, text_color=hudTextColorInput, text_size=hudTextSize)
        table.cell_set_bgcolor(statusTable, 1, 9, squeezeColor)

        table.cell(statusTable, 0, 10, 'ÏûÑÍ≥Ñ¬∑Î™®Î©òÌÖÄ', text_color=hudTextColorInput, text_size=hudTextSize)
        table.cell_set_bgcolor(statusTable, 0, 10, labelBg)
        table.cell(statusTable, 1, 10, thresholdInfo, text_color=hudTextColorInput, text_size=hudTextSize)
        table.cell_set_bgcolor(statusTable, 1, 10, labelBg)
    else
        if not na(statusTable)
            table.delete(statusTable)
        statusTable := na
        statusTablePosCache := ''

if strategy.position_size != 0
    barsHeld += 1
    if strategy.position_size > 0
        highestSinceEntry := na(highestSinceEntry) ? high : math.max(highestSinceEntry, high)
        lowestSinceEntry := na(lowestSinceEntry) ? low : math.min(lowestSinceEntry, low)
    else
        lowestSinceEntry := na(lowestSinceEntry) ? low : math.min(lowestSinceEntry, low)
        highestSinceEntry := na(highestSinceEntry) ? high : math.max(highestSinceEntry, high)
else
    barsHeld := 0
    highestSinceEntry := na
    lowestSinceEntry := na

if strategy.position_size == 0 or not useFixedStop
    fixedStopPriceLong := na
    fixedStopPriceShort := na

positionSize = strategy.position_size
avgPrice = strategy.position_avg_price
positionDir = positionSize > 0 ? 1 : positionSize < 0 ? -1 : 0
positionSizePrev = nz(strategy.position_size[1])

openedLongThisBar = false
openedShortThisBar = false

if useFixedStop
    openedLongThisBar := positionSize > 0 and positionSizePrev <= 0
    openedShortThisBar := positionSize < 0 and positionSizePrev >= 0
    if openedLongThisBar
        float fsLong = calcFixedStopPriceLong(avgPrice)
        if not na(fsLong)
            fixedStopPriceLong := fsLong
    if openedShortThisBar
        float fsShort = calcFixedStopPriceShort(avgPrice)
        if not na(fsShort)
            fixedStopPriceShort := fsShort
    // Ï§ëÍ∞Ñ ÌôúÏÑ±Ìôî ÏßÄÏõê
    if positionDir == 1 and na(fixedStopPriceLong)
        float fsLong = calcFixedStopPriceLong(avgPrice)
        if not na(fsLong)
            fixedStopPriceLong := fsLong
    if positionDir == -1 and na(fixedStopPriceShort)
        float fsShort = calcFixedStopPriceShort(avgPrice)
        if not na(fsShort)
            fixedStopPriceShort := fsShort

longCrossOk = requireCross ? crossUp : true
shortCrossOk = requireCross ? crossDown : true
baseLongTrigger = longCrossOk and momentum < buyThresh and fluxHist > 0
baseShortTrigger = shortCrossOk and momentum > sellThresh and fluxHist < 0
baseLongSignal = debugForceLong or baseLongTrigger
baseShortSignal = debugForceShort or baseShortTrigger

longOk = true
shortOk = true
if useAdx
    longOk := longOk and adxSeries > adxThresh
    shortOk := shortOk and adxSeries > adxThresh
if useObv
    longOk := longOk and obvSlopeVal > 0
    shortOk := shortOk and obvSlopeVal < 0
if useAtrDiff
    longOk := longOk and atrDiff > 0
    shortOk := shortOk and atrDiff < 0
if useHtfTrend
    longOk := longOk and htfTrendUp
    shortOk := shortOk and htfTrendDown
if useHmaFilter
    longOk := longOk and close > hmaValue
    shortOk := shortOk and close < hmaValue
if useRangeFilter
    longOk := longOk and not inRangeBox
    shortOk := shortOk and not inRangeBox
if useDistanceGuard
    longOk := longOk and (atrSeries(distanceAtrLen) > 0) and ((math.abs(close - ta.sma(close, distanceAtrLen)) / atrSeries(distanceAtrLen)) <= distanceMaxAtr) and ((math.abs(close - ta.ema(close, distanceTrendLen)) / atrSeries(distanceAtrLen)) <= distanceMaxAtr)
    shortOk := shortOk and (atrSeries(distanceAtrLen) > 0) and ((math.abs(close - ta.sma(close, distanceAtrLen)) / atrSeries(distanceAtrLen)) <= distanceMaxAtr) and ((math.abs(close - ta.ema(close, distanceTrendLen)) / atrSeries(distanceAtrLen)) <= distanceMaxAtr)
if useDisparityGuard
    longOk := longOk and disparityOk
    shortOk := shortOk and disparityOk
longOk := longOk and regimeLongOk
shortOk := shortOk and regimeShortOk

if useSqzGate
    longOk := longOk and gateSqValid
    shortOk := shortOk and gateSqValid

enterLong = allowLongEntry and canTrade and baseLongSignal and longOk and positionDir == 0 and reentryCountdown == 0
enterShort = allowShortEntry and canTrade and baseShortSignal and shortOk and positionDir == 0 and reentryCountdown == 0

alertcondition(enterLong, title='Î°± ÏßÑÏûÖ Ïã†Ìò∏', message='Îß§ÏßÅ1Î∂ÑVN: Î°± ÏßÑÏûÖ Ï°∞Í±¥ Ï∂©Ï°±')
alertcondition(enterShort, title='Ïàè ÏßÑÏûÖ Ïã†Ìò∏', message='Îß§ÏßÅ1Î∂ÑVN: Ïàè ÏßÑÏûÖ Ï°∞Í±¥ Ï∂©Ï°±')

if not barstate.isconfirmed
    enterLong := false
    enterShort := false

baseLongSignalConfirmed = barstate.isconfirmed ? baseLongSignal : false
baseShortSignalConfirmed = barstate.isconfirmed ? baseShortSignal : false

if useReversal and reversalCountdown == 0 and positionDir == 0 and lastDir != 0 and canTrade and barstate.isconfirmed
    if lastDir == 1
        enterShort := true
    else if lastDir == -1
        enterLong := true
    lastDir := 0

exitLong = false
exitShort = false
exitLongReason = ''
exitShortReason = ''

translateExitReason(reason, isLong) =>
    dirLabel = isLong ? 'Î°±' : 'Ïàè'
    switch reason
        'opposite' => 'Î∞òÎåÄ Ïã†Ìò∏ Ï≤≠ÏÇ∞ (' + (isLong ? 'Ïàè Ïã†Ìò∏ Í∞êÏßÄ' : 'Î°± Ïã†Ìò∏ Í∞êÏßÄ') + ')'
        'mom_fade' => 'Î™®Î©òÌÖÄ ÏïΩÌôî Ï≤≠ÏÇ∞ (' + dirLabel + ')'
        'time_stop' => 'ÏµúÎåÄ Î≥¥Ïú† ÏãúÍ∞Ñ Ï¥àÍ≥º Ï≤≠ÏÇ∞ (' + dirLabel + ')'
        'kasa_exit' => 'KASA Ï°∞Í±¥ Ï∂©Ï°± Ï≤≠ÏÇ∞ (' + dirLabel + ')'
        'shock' => 'Î≥ÄÎèôÏÑ± ÏáºÌÅ¨ Ï≤≠ÏÇ∞ (' + dirLabel + ')'
        => 'Í∏∞ÌÉÄ Ï≤≠ÏÇ∞ (' + dirLabel + ')'

barsSinceMomFadeHistLong = ta.barssince(momFadeHist <= 0)
barsSinceMomFadeHistShort = ta.barssince(momFadeHist >= 0)

if positionDir > 0
    if exitOpposite and baseShortSignalConfirmed and barsHeld >= minHoldBarsInput
        exitLong := true
        exitLongReason := 'opposite'
    fadeAbsFalling = momFadeAbs < momFadeAbs[1]
    fadeAbsTwo = not useMomFade or (momFadeAbs <= momFadeAbs[1] and momFadeAbs[1] <= momFadeAbs[2])
    fadeDelayLong = momFadeZeroDelay <= 0 or barsSinceMomFadeHistLong > momFadeZeroDelay
    fadeMinAbsOk = momFadeMinAbs <= 0 or momFadeAbs >= momFadeMinAbs
    fadeReleaseOk = not useMomFade or not momFadeReleaseOnly or gateSqValid
    if useMomFade and momFadeHist > 0 and fadeAbsFalling and fadeAbsTwo and fadeDelayLong and fadeMinAbsOk and fadeReleaseOk and barsHeld >= momFadeBars
        exitLong := true
        exitLongReason := 'mom_fade'
    if useTimeStop and maxHoldBars > 0 and barsHeld >= maxHoldBars
        exitLong := true
        exitLongReason := 'time_stop'
    if useKasa and kasaRsiVal < kasaRsiOB and kasaRsiVal[1] >= kasaRsiOB
        exitLong := true
        exitLongReason := 'kasa_exit'
else if positionDir < 0
    if exitOpposite and baseLongSignalConfirmed and barsHeld >= minHoldBarsInput
        exitShort := true
        exitShortReason := 'opposite'
    fadeAbsFallingS = momFadeAbs < momFadeAbs[1]
    fadeAbsTwoS = not useMomFade or (momFadeAbs <= momFadeAbs[1] and momFadeAbs[1] <= momFadeAbs[2])
    fadeDelayShort = momFadeZeroDelay <= 0 or barsSinceMomFadeHistShort > momFadeZeroDelay
    fadeMinAbsOkS = momFadeMinAbs <= 0 or momFadeAbs >= momFadeMinAbs
    fadeReleaseOkS = not useMomFade or not momFadeReleaseOnly or gateSqValid
    if useMomFade and momFadeHist < 0 and fadeAbsFallingS and fadeAbsTwoS and fadeDelayShort and fadeMinAbsOkS and fadeReleaseOkS and barsHeld >= momFadeBars
        exitShort := true
        exitShortReason := 'mom_fade'
    if useTimeStop and maxHoldBars > 0 and barsHeld >= maxHoldBars
        exitShort := true
        exitShortReason := 'time_stop'
    if useKasa and kasaRsiVal > kasaRsiOS and kasaRsiVal[1] <= kasaRsiOS
        exitShort := true
        exitShortReason := 'kasa_exit'

isShock = false
if useShock
    atrFast = atrSeries(atrFastLen)
    atrSlow = ta.sma(atrFast, atrSlowLen)
    isShock := atrFast > atrSlow * shockMult
if positionDir > 0 and isShock and shockAction == 'Ï¶âÏãú Ï≤≠ÏÇ∞'
    exitLong := true
    exitLongReason := 'shock'
if positionDir < 0 and isShock and shockAction == 'Ï¶âÏãú Ï≤≠ÏÇ∞'
    exitShort := true
    exitShortReason := 'shock'

longExitReasonLabel = exitLong ? translateExitReason(exitLongReason, true) : ''
shortExitReasonLabel = exitShort ? translateExitReason(exitShortReason, false) : ''

if positionDir > 0 and exitLong
    strategy.close('Ìè¨ÏßÄÏÖò', comment=longExitReasonLabel)
    lastDir := 1
    reentryCountdown := reentryBars
    reversalCountdown := int(reversalDelaySec / 60.0)
if positionDir < 0 and exitShort
    strategy.close('Ìè¨ÏßÄÏÖò', comment=shortExitReasonLabel)
    lastDir := -1
    reentryCountdown := reentryBars
    reversalCountdown := int(reversalDelaySec / 60.0)

float atrTrailSeries = atrSeries(atrTrailLen)
float dynFactor = 1.0
if useDynVol
    dynFactor := clamp(((atrTrailSeries / close) + (ta.stdev(close, 20) * 2 / close) + (math.abs(close - ta.sma(close, 50)) / close)) / 3.0 + 1.0, 0.5, 3.0)

float swingLowForStop = ta.lowest(low, stopLookback)
float swingHighForStop = ta.highest(high, stopLookback)

float stopLong = na
float stopShort = na
float targetLong = na
float targetShort = na

if positionDir > 0
    if useAtrTrail and not na(atrTrailSeries)
        stopLong := close - atrTrailSeries * atrTrailMult * dynFactor
    if useStopLoss
        stopLong := maxIgnoreNaN(stopLong, swingLowForStop)
    if useFixedStop and not na(fixedStopPriceLong)
        stopLong := maxIgnoreNaN(stopLong, fixedStopPriceLong)
    if useBreakevenStop and not na(highestSinceEntry) and not na(atrTrailSeries)
        move = highestSinceEntry - avgPrice
        trigger = atrTrailSeries * breakevenMult * dynFactor
        if move >= trigger
            stopLong := maxIgnoreNaN(stopLong, avgPrice)
    if useBeTiers and not na(highestSinceEntry)
        atrSeed = atrOsc
        if atrSeed > 0 and highestSinceEntry - avgPrice >= atrSeed
            stopLong := maxIgnoreNaN(stopLong, avgPrice)
    if useAtrProfit and not na(atrTrailSeries)
        targetLong := avgPrice + atrTrailSeries * atrProfitMult * dynFactor
else if positionDir < 0
    if useAtrTrail and not na(atrTrailSeries)
        stopShort := close + atrTrailSeries * atrTrailMult * dynFactor
    if useStopLoss
        stopShort := minIgnoreNaN(stopShort, swingHighForStop)
    if useFixedStop and not na(fixedStopPriceShort)
        stopShort := minIgnoreNaN(stopShort, fixedStopPriceShort)
    if useBreakevenStop and not na(lowestSinceEntry) and not na(atrTrailSeries)
        move = avgPrice - lowestSinceEntry
        trigger = atrTrailSeries * breakevenMult * dynFactor
        if move >= trigger
            stopShort := minIgnoreNaN(stopShort, avgPrice)
    if useBeTiers and not na(lowestSinceEntry)
        atrSeed = atrOsc
        if atrSeed > 0 and avgPrice - lowestSinceEntry >= atrSeed
            stopShort := minIgnoreNaN(stopShort, avgPrice)
    if useAtrProfit and not na(atrTrailSeries)
        targetShort := avgPrice - atrTrailSeries * atrProfitMult * dynFactor

if positionDir > 0
    if not na(stopLong) and low <= stopLong
        strategy.close('Ìè¨ÏßÄÏÖò', comment='ÏÜêÏ†àÍ∞Ä Ï≤≠ÏÇ∞ (Î°±)')
    if not na(targetLong) and high >= targetLong
        strategy.close('Ìè¨ÏßÄÏÖò', comment='ATR Î™©Ìëú Ï≤≠ÏÇ∞ (Î°±)')
if positionDir < 0
    if not na(stopShort) and high >= stopShort
        strategy.close('Ìè¨ÏßÄÏÖò', comment='ÏÜêÏ†àÍ∞Ä Ï≤≠ÏÇ∞ (Ïàè)')
    if not na(targetShort) and low <= targetShort
        strategy.close('Ìè¨ÏßÄÏÖò', comment='ATR Î™©Ìëú Ï≤≠ÏÇ∞ (Ïàè)')

if exitLong
    label.new(bar_index, high, text=longExitReasonLabel, yloc=yloc.abovebar, color=color.new(color.maroon, 70), textcolor=color.white, style=label.style_label_down, size=size.tiny)

if exitShort
    label.new(bar_index, low, text=shortExitReasonLabel, yloc=yloc.belowbar, color=color.new(color.teal, 70), textcolor=color.white, style=label.style_label_up, size=size.tiny)

// alertconditionÏùÑ ÏúÑÌïú ÏãúÎ¶¨Ï¶à Î≥ÄÏàò
exitLongReasonSeries = exitLong ? longExitReasonLabel : na
exitShortReasonSeries = exitShort ? shortExitReasonLabel : na
alertcondition(exitLong, title='Î°± Ï≤≠ÏÇ∞ Ïã†Ìò∏', message='Îß§ÏßÅ1Î∂ÑVN: Î°± Ï≤≠ÏÇ∞ ‚Äî Ï°∞Í±¥ Ï∂©Ï°±')
alertcondition(exitShort, title='Ïàè Ï≤≠ÏÇ∞ Ïã†Ìò∏', message='Îß§ÏßÅ1Î∂ÑVN: Ïàè Ï≤≠ÏÇ∞ ‚Äî Ï°∞Í±¥ Ï∂©Ï°±')

calcOrderSize(price, stopDistance, riskMult) =>
    result = 0.0
    if price > 0
        effectiveScale = baseRiskPct
        if useDrawdownScaling and peakEquity > 0
            dd = (peakEquity - equity) / peakEquity * 100
            if dd > drawdownTriggerPct
                effectiveScale *= drawdownRiskScale
        if usePerfAdaptiveRisk and array.size(recentPnls) >= parMinTrades
            wins = 0
            for i = 0 to array.size(recentPnls) - 1
                if array.get(recentPnls, i) > 0
                    wins += 1
            winRate = array.size(recentPnls) > 0 ? wins / array.size(recentPnls) * 100 : 0
            if winRate >= parHotWinRate
                effectiveScale *= parHotMult
            else if winRate <= parColdWinRate
                effectiveScale *= parColdMult
        mult = math.max(riskMult, 0.0)
        if not useSizingOverride
            pctToUse = math.max(baseQtyPercent * mult * (baseRiskPct > 0 ? effectiveScale / baseRiskPct : 1.0), 0.0)
            capitalPortion = tradableCapital * pctToUse / 100.0
            result := (capitalPortion * leverage) / price
        else if sizingMode == 'ÏûêÎ≥∏ ÎπÑÏú®'
            pctToUse = math.max(advancedPercent * mult, 0.0)
            capitalPortion = tradableCapital * pctToUse / 100.0
            result := (capitalPortion * leverage) / price
        else if sizingMode == 'Í≥†Ï†ï Í∏àÏï° (USD)'
            usdToUse = math.max(fixedUsdAmount * mult, 0.0)
            result := (usdToUse * leverage) / price
        else if sizingMode == 'Í≥†Ï†ï Í≥ÑÏïΩ'
            result := math.max(fixedContractSize * mult, 0.0)
        else if sizingMode == 'Î¶¨Ïä§ÌÅ¨ Í∏∞Î∞ò'
            if riskSizingType == 'Í≥†Ï†ï Í≥ÑÏïΩ'
                result := math.max(riskContractSize * mult, 0.0)
            else if stopDistance > 0 and not na(stopDistance)
                riskPct = math.max(effectiveScale * mult, 0.0)
                riskCapital = tradableCapital * riskPct / 100.0
                result := riskCapital > 0 ? riskCapital / (stopDistance + slipValue) : 0.0
    result

if positionDir == 0
    if enterLong
        float entryPrice = close
        float prospectiveStop = calcProspectiveStopLong(entryPrice, atrTrailSeries, dynFactor, swingLowForStop)
        float stopDist = not na(prospectiveStop) ? entryPrice - prospectiveStop : na
        if na(stopDist) or stopDist <= 0
            stopDist := atrOsc
        if na(stopDist) or stopDist <= 0
            stopDist := tickSize
        float stopForSize = math.max(stopDist, tickSize)
        guardOk = not useStopDistanceGuard or na(atrOsc) or stopForSize <= atrOsc * maxStopAtrMult
        float qty = calcOrderSize(entryPrice, stopForSize, 1.0)
        if guardOk and qty > 0
            strategy.entry('Ìè¨ÏßÄÏÖò', strategy.long, qty=qty)
            float fsLong = calcFixedStopPriceLong(entryPrice)
            if not na(fsLong)
                fixedStopPriceLong := fsLong
            lastEntryPrice := close
            lastEntryQty := qty
            lastPositionDir := 1
            highestSinceEntry := high
            lowestSinceEntry := low
            reversalCountdown := int(reversalDelaySec / 60.0)
            reentryCountdown := reentryBars
    if enterShort
        float entryPrice = close
        float prospectiveStop = calcProspectiveStopShort(entryPrice, atrTrailSeries, dynFactor, swingHighForStop)
        float stopDist = not na(prospectiveStop) ? prospectiveStop - entryPrice : na
        if na(stopDist) or stopDist <= 0
            stopDist := atrOsc
        if na(stopDist) or stopDist <= 0
            stopDist := tickSize
        float stopForSize = math.max(stopDist, tickSize)
        guardOk = not useStopDistanceGuard or na(atrOsc) or stopForSize <= atrOsc * maxStopAtrMult
        float qty = calcOrderSize(entryPrice, stopForSize, 1.0)
        if guardOk and qty > 0
            strategy.entry('Ìè¨ÏßÄÏÖò', strategy.short, qty=qty)
            float fsShort = calcFixedStopPriceShort(entryPrice)
            if not na(fsShort)
                fixedStopPriceShort := fsShort
            lastEntryPrice := close
            lastEntryQty := qty
            lastPositionDir := -1
            highestSinceEntry := high
            lowestSinceEntry := low
            reversalCountdown := int(reversalDelaySec / 60.0)
            reentryCountdown := reentryBars

var int prevClosedTrades = 0
currentClosedTrades = strategy.closedtrades
if currentClosedTrades > prevClosedTrades
    for idx = prevClosedTrades to currentClosedTrades - 1
        tradeProfit = strategy.closedtrades.profit(idx)
        if tradeProfit < 0
            lossStreak += 1
            dailyLosses += 1
        else if tradeProfit > 0
            lossStreak := 0
        if usePerfAdaptiveRisk
            array.push(recentPnls, tradeProfit)
            if array.size(recentPnls) > parLookback
                array.shift(recentPnls)
    prevClosedTrades := currentClosedTrades

if positionDir == 0 and (exitLong or exitShort)
    lastDir := lastPositionDir

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// HUD Ï∂úÎ†•
hudTitle = 'üìä Îß§ÏßÅ1Î∂ÑVN HUD'
positionText = positionDir > 0 ? 'Î°± Î≥¥Ïú†' : positionDir < 0 ? 'Ïàè Î≥¥Ïú†' : 'Ìè¨ÏßÄÏÖò ÏóÜÏùå'
guardText = guardFrozen ? 'Ï§ëÏßÄ' : 'Í∞ÄÎèô'
canTradeText = canTrade ? 'Í∞ÄÎä•' : 'Ï§ëÏßÄ'
squeezeStateText = gateSqOn == 1 ? 'ÏïïÏ∂ï ÏßÑÌñâ' : gateSqRelease ? 'Ìï¥Ï†ú Ïã†Ìò∏' : 'ÎåÄÍ∏∞'
roundedBuyHud = math.round(buyThresh * 100.0) / 100.0
roundedSellHud = math.round(sellThresh * 100.0) / 100.0
roundedMomentumHud = math.round(momentum * 100.0) / 100.0
hudText = hudTitle + '\n'
hudText += 'Ìè¨ÏßÄÏÖò: ' + positionText + ' / Í±∞ÎûòÏÉÅÌÉú: ' + canTradeText + '\n'
hudText += 'Ïä§ÌÄ¥Ï¶à: ' + squeezeStateText + ' / Î™®Î©òÌÖÄ: ' + str.tostring(roundedMomentumHud) + '\n'
hudText += 'ÏûÑÍ≥ÑÍ∞í (Îß§Ïàò/Îß§ÎèÑ): ' + str.tostring(roundedBuyHud) + ' / ' + str.tostring(roundedSellHud) + '\n'
hudText += 'Í∞ÄÎìú: ' + guardText + ' (Î∞úÎèô ' + str.tostring(guardFiredTotal) + ') / Ïó∞ÏÜçÏÜêÏã§ ' + str.tostring(lossStreak) + '\n'
hudText += 'Ï∂úÍ∏à Í∞ÄÎä•: ' + str.tostring(totalWithdrawable, format.mintick) + ' / ÎàÑÏ†ÅÏÜêÏùµ: ' + str.tostring(strategy.netprofit, format.mintick) + '\n'
hudText += 'ÏùºÏÜêÏùµ: ' + str.tostring(dailyPnl, format.mintick) + ' / ÏùºÏÜêÏã§ÌöüÏàò: ' + str.tostring(dailyLosses) + '\n'
hudText += 'Í∞ÄÏö©ÏûêÎ≥∏: ' + str.tostring(tradableCapital, format.mintick) + '\n'
if not na(lastEntryPrice)
    hudText += 'ÎßàÏßÄÎßâ ÏßÑÏûÖÍ∞Ä: ' + str.tostring(lastEntryPrice, format.price) + ' / ÏàòÎüâ: ' + str.tostring(lastEntryQty) + '\n'
hudText += 'Î†àÎ≤ÑÎ¶¨ÏßÄ: ' + str.tostring(leverage, format.mintick) + 'Î∞∞ / ÏÑ†Ï†úÌã±: ' + str.tostring(preemptTicks)

atrForHudBase = nz(atrOsc, atrSeries(oscLen))

if barstate.islast and showPriceHud
    atrForHud = atrForHudBase
    basePrice = priceHudAnchorInput == 'ÏúÑÏ™Ω' ? high : low
    offsetValue = nz(atrForHud, 0) * priceHudAtrOffset
    hudY = priceHudAnchorInput == 'ÏúÑÏ™Ω' ? basePrice + offsetValue : basePrice - offsetValue
    if na(hudY)
        hudY := basePrice
    labelSize = hudTableTextSizeInput == 'ÏûëÍ≤å' ? size.small : hudTableTextSizeInput == 'ÌÅ¨Í≤å' ? size.large : size.normal
    if na(priceHudLabel)
        priceHudLabel := label.new(bar_index, hudY, hudText, xloc=xloc.bar_index, yloc=yloc.price, style=label.style_label_left, color=hudBgColorInput, textcolor=hudTextColorInput, size=labelSize)
    else
        label.set_xy(priceHudLabel, bar_index, hudY)
        label.set_text(priceHudLabel, hudText)
        label.set_color(priceHudLabel, hudBgColorInput)
        label.set_textcolor(priceHudLabel, hudTextColorInput)
        label.set_style(priceHudLabel, label.style_label_left)
        label.set_size(priceHudLabel, labelSize)
else if not barstate.islast or not showPriceHud
    if not na(priceHudLabel)
        label.delete(priceHudLabel)
    priceHudLabel := na

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// ÏãúÍ∞ÅÌôî ÌîåÎ°Ø & ÌïòÏù¥ÎùºÏù¥Ìä∏
momentumPlotValue = barstate.isconfirmed ? momentum : nz(momentum[1], momentum)
signalPlotValue = barstate.isconfirmed ? momSignal : nz(momSignal[1], momSignal)
buyThreshPlotValue = barstate.isconfirmed ? buyThresh : nz(buyThresh[1], buyThresh)
sellThreshPlotValue = barstate.isconfirmed ? sellThresh : nz(sellThresh[1], sellThresh)

momentumPlotSeries = plot(showMomentumDecorators ? momentumPlotValue : na, title='Momentum (ÌôïÏ†ï)', color=color.new(color.teal, 0), linewidth=2)
signalPlotSeries = plot(showMomentumDecorators ? signalPlotValue : na, title='Signal (ÌôïÏ†ï)', color=color.new(color.orange, 0), linewidth=1)
buyThreshSeries = plot(showMomentumDecorators ? buyThreshPlotValue : na, title='Buy Threshold', color=color.new(color.green, 40), linewidth=1)
sellThreshSeries = plot(showMomentumDecorators ? sellThreshPlotValue : na, title='Sell Threshold', color=color.new(color.red, 40), linewidth=1)
hline(0, 'Momentum Zero', color=color.new(color.gray, 70))

fill(momentumPlotSeries, signalPlotSeries, color=showMomentumDecorators ? color.new(color.teal, 88) : na)
fill(buyThreshSeries, sellThreshSeries, color=showMomentumDecorators ? color.new(color.purple, 92) : na)

longSignalMarker = showSignalMarkers and baseLongSignalConfirmed and longOk ? buyThreshPlotValue : na
shortSignalMarker = showSignalMarkers and baseShortSignalConfirmed and shortOk ? sellThreshPlotValue : na
plotshape(longSignalMarker, title='Î°± Ï°∞Í±¥ Ï∂©Ï°±', style=shape.triangleup, location=location.absolute, color=color.new(color.lime, 0), size=size.tiny, text='Î°±', textcolor=color.white)
plotshape(shortSignalMarker, title='Ïàè Ï°∞Í±¥ Ï∂©Ï°±', style=shape.triangledown, location=location.absolute, color=color.new(color.red, 0), size=size.tiny, text='Ïàè', textcolor=color.white)

plotshape(showSignalMarkers and openedLongThisBar, title='Î°± ÏßÑÏûÖ', location=location.belowbar, style=shape.arrowup, color=color.new(color.lime, 0), text='Î°±', textcolor=color.white, size=size.small)
plotshape(showSignalMarkers and openedShortThisBar, title='Ïàè ÏßÑÏûÖ', location=location.abovebar, style=shape.arrowdown, color=color.new(color.red, 0), text='Ïàè', textcolor=color.white, size=size.small)

sqzActiveBg = showSqueezeHighlight and gateSqOn == 1 ? color.new(color.blue, 90) : na
sqzReleaseBg = showSqueezeHighlight and gateSqRelease ? color.new(color.purple, 88) : na
bgcolor(sqzActiveBg, title='Squeeze Active BG')
bgcolor(sqzReleaseBg, title='Squeeze Release BG')
bgcolor(guardFrozen ? color.new(color.red, 90) : na, title='Guard Freeze BG')len          = input.int (12   , title="Momentum Length"       , group=gOsc, minval=5 , maxval=100)
sig          = input.int (3    , title="Signal Length"         , group=gOsc, minval=1 , maxval=20)
bbLen        = input.int (20   , title="BB Length"             , group=gOsc, minval=5 , maxval=200)
bbMult       = input.float(1.4 , title="BB Multiplier"         , group=gOsc, minval=0.1, maxval=5.0 , step=0.1)
kcLen        = input.int (18   , title="KC Length (ATR)"       , group=gOsc, minval=5 , maxval=200)
kcMult       = input.float(1.0 , title="KC Multiplier"         , group=gOsc, minval=0.1, maxval=5.0 , step=0.1)

// --- 2. Î∞©Ìñ•ÏÑ± ÌîåÎü≠Ïä§ ---
gDF   = "2. Î∞©Ìñ•ÏÑ± ÌîåÎü≠Ïä§"
showFlux    = input.bool(true , title="ÌîåÎü≠Ïä§ ÏãúÍ∞ÅÌôî"         , group=gDF)
dfl          = input.int (14  , title="Flux Length"           , group=gDF, minval=5 , maxval=100)
dfSmoothLen  = input.int (1   , title="ÌîåÎü≠Ïä§ Ïä§Î¨¥Îî©"          , group=gDF, minval=1 , maxval=50)
dfh          = input.bool(true, title="Heikin-Ashi Î≥ÄÌôò ÏÇ¨Ïö©" , group=gDF)

// --- 6. Î™®ÎîîÌååÏù¥Îìú ÏòµÏÖò ---
gMod = "6. Î™®ÎîîÌååÏù¥Îìú"
// Î™®ÎîîÌååÏù¥Îìú DMI/ADX Í∏∞Î∞ò Î∞©Ìñ•ÏÑ± ÌîåÎü≠Ïä§ ÏÇ¨Ïö© Ïó¨Î∂Ä
useModFlux   = input.bool(false, title="Î™®ÎîîÌååÏù¥Îìú ÌîåÎü≠Ïä§(DMI/ADX) ÏÇ¨Ïö©", group=gMod)
// Î™®Î©òÌÖÄ Í≥ÑÏÇ∞ Î∞©Ïãù ÏÑ†ÌÉù: Í∏∞Î≥∏(KC), AVG, Deluxe, Mod.  Mod Ïä§ÌÉÄÏùºÏùÄ ATR Ï†ïÍ∑úÌôîÎ•º Ìè¨Ìï®ÌïòÎ©∞ Ïù¥Ï†Ñ
// `useModSqueeze` ÏòµÏÖòÏùÑ ÎåÄÏ≤¥Ìï©ÎãàÎã§.
momStyle     = input.string("KC", title="Î™®Î©òÌÖÄ Í≥ÑÏÇ∞ Î∞©Ïãù", options=["KC", "AVG", "Deluxe", "Mod"], group=gMod)
// Î™®Î©òÌÖÄ Ïã†Ìò∏ÏÑ† Ïù¥ÎèôÌèâÍ∑† Ï¢ÖÎ•ò: Í∏∞Î≥∏(SMA), EMA, HMA. Í∏∞Î≥∏Í∞í "Í∏∞Î≥∏"ÏùÄ SMAÏôÄ ÎèôÏùºÌïòÍ≤å Ï≤òÎ¶¨Îê©ÎãàÎã§.
maType       = input.string("Í∏∞Î≥∏", title="Î™®Î©òÌÖÄ Ïã†Ìò∏ÏÑ† ÌÉÄÏûÖ", options=["Í∏∞Î≥∏","EMA","HMA"], group=gMod)

// --- 7. Î¶¨Ïä§ÌÅ¨ & ÏõîÎ†õ ---
gRisk = "7. Î¶¨Ïä§ÌÅ¨ & ÏõîÎ†õ"
baseQtyPercent       = input.float(30.0, title="Í∏∞Î≥∏ Ìè¨ÏßÄÏÖò ÎπÑÏú® (%)", group=gRisk, minval=0.0, maxval=100.0, step=0.1)
leverage             = input.float(10.0, title="Î†àÎ≤ÑÎ¶¨ÏßÄ", group=gRisk, minval=0.1, maxval=100.0, step=0.1)
useWallet            = input.bool(false, title="ÏõîÎ†õ Î∂ÑÎ¶¨ ÏÇ¨Ïö©", group=gRisk)
profitReservePct     = input.float(20.0, title="Ïù¥Ïùµ Ï†ÅÎ¶Ω ÎπÑÏú® (%)", group=gRisk, minval=0.0, maxval=100.0, step=0.1, inline="reserve")
applyReserveToSizing = input.bool(true, title="Ï†ÅÎ¶ΩÏï° Ï†úÏô∏ ÌõÑ ÏÇ¨Ïù¥Ïßï", group=gRisk, inline="reserve")
minTradableCapital   = input.float(250.0, title="ÏµúÏÜå Ïö¥Ïö© ÏûêÎ≥∏", group=gRisk, minval=0.0)
useDailyLossGuard    = input.bool(false, title="ÏùºÏùº ÏÜêÏã§ ÌïúÎèÑ ÏÇ¨Ïö©", group=gRisk)
dailyLossLimit       = input.float(80.0, title="ÏùºÏùº ÏÜêÏã§ ÌïúÎèÑ", group=gRisk)
useLossStreakGuard   = input.bool(false, title="Ïó∞ÏÜç ÏÜêÏã§ Ï∞®Îã®", group=gRisk)
maxConsecutiveLosses = input.int(3, title="ÌóàÏö© Ïó∞ÏÜç ÏÜêÏã§ Ïàò", group=gRisk, minval=1)
maxDailyLosses       = input.int(0, title="ÏùºÏùº ÌóàÏö© ÏÜêÏã§ Í±∞Îûò Ïàò", group=gRisk, minval=0)
// --- 3. Ï≤≠ÏÇ∞ ÏòµÏÖò ---
gExit = "3. Ï≤≠ÏÇ∞ ÏòµÏÖò"
exitOpposite = input.bool(true , title="Î∞òÎåÄ Ïã†Ìò∏ Ï≤≠ÏÇ∞"      , group=gExit)
useMomFade   = input.bool(false, title="Î™®Î©òÌÖÄ ÌéòÏù¥Îìú Ï≤≠ÏÇ∞"  , group=gExit)
fadeMode     = input.string("VN", title="ÌéòÏù¥Îìú Î™®Îìú", options=["VN", "Legacy"], group=gExit)
useAtrStop   = input.bool(true , title="ATR ÏÜêÏ†à ÏÇ¨Ïö©"        , group=gExit)
atrStopMult  = input.float(1.5 , title="ATR ÏÜêÏ†à Mult"        , group=gExit, minval=0.1, maxval=5.0, step=0.1)
useFixedStop = input.bool(false, title="Í≥†Ï†ï % ÏÜêÏ†à"          , group=gExit)
fixedStopPct = input.float(0.8 , title="Í≥†Ï†ï ÏÜêÏ†à %"         , group=gExit, minval=0.1, maxval=5.0, step=0.1)
useStopLoss  = input.bool(false, title="Ï†ÑÍ≥†/Ï†ÑÏ†Ä ÏÜêÏ†à"       , group=gExit)
stopLookback = input.int (5    , title="Ï†ÑÍ≥†/Ï†ÑÏ†Ä ÌÉêÏÉâ"      , group=gExit, minval=2, maxval=50)
usePivotStop = input.bool(false, title="ÌîºÎ¥á ÏÜêÏ†à"            , group=gExit)
pivotLen     = input.int (5    , title="ÌîºÎ¥á Í∏∏Ïù¥"           , group=gExit, minval=2, maxval=20)
useAtrTrail  = input.bool(false, title="ATR Ìä∏Î†àÏùº"           , group=gExit)
atrTrailLen  = input.int (14   , title="ATR Ìä∏Î†àÏùº Í∏∏Ïù¥"      , group=gExit, minval=1, maxval=200)
atrTrailMult = input.float(2.0 , title="ATR Ìä∏Î†àÏùº Mult"      , group=gExit, minval=0.1, maxval=5.0, step=0.1)
useBreakeven = input.bool(false, title="Î∏åÎ†àÏù¥ÌÅ¨Ïù¥Î∏ê Ïä§ÌÉë"    , group=gExit)
breakevenMult= input.float(1.0 , title="Î∏åÎ†àÏù¥ÌÅ¨Ïù¥Î∏ê ATR Mult", group=gExit, minval=0.1, maxval=5.0, step=0.1)
useTimeStop  = input.bool(false, title="ÏãúÍ∞Ñ ÏÜêÏ†à"            , group=gExit)
maxHoldBars  = input.int (0    , title="ÏµúÎåÄ Î≥¥Ïú† Î¥â Ïàò"      , group=gExit, minval=0, maxval=200)

// --- 4. ÌïÑÌÑ∞ ---
gFilt = "4. ÌïÑÌÑ∞"
useHtfTrend    = input.bool(false, title="ÏÉÅÏúÑ ÌÉÄÏûÑÌîÑÎ†àÏûÑ Ï∂îÏÑ∏ ÌïÑÌÑ∞", group=gFilt)
htfTrendTf     = input.timeframe("240", title="ÏÉÅÏúÑ ÌÉÄÏûÑÌîÑÎ†àÏûÑ"      , group=gFilt)
htfMaLen       = input.int (50   , title="ÏÉÅÏúÑÎ¥â EMA Length"       , group=gFilt, minval=5, maxval=400)
useRangeFilter = input.bool(false, title="ÏÉÅÏúÑÎ¥â Î†àÏù∏ÏßÄ ÌïÑÌÑ∞", group=gFilt)
rangeTf        = input.timeframe("5", title="Î†àÏù∏ÏßÄ Ï∏°Ï†ï TF" , group=gFilt)
rangeBars      = input.int (20  , title="Î†àÏù∏ÏßÄ Ï∏°Ï†ï Î¥â Ïàò"  , group=gFilt, minval=5, maxval=200)
rangePercent   = input.float(1.0, title="Î†àÏù∏ÏßÄ ÌïúÍ≥Ñ (%)"    , group=gFilt, minval=0.1, maxval=10.0, step=0.1)

gMsg = "5. ÏïåÎ¶º"
alertLongEntry  = input.string('{"action":"enter_long"}', title="Î°± ÏßÑÏûÖ", group=gMsg)
alertShortEntry = input.string('{"action":"enter_short"}', title="Ïàè ÏßÑÏûÖ", group=gMsg)
alertExitLong   = input.string('{"action":"exit_long"}', title="Î°± Ï≤≠ÏÇ∞", group=gMsg)
alertExitShort  = input.string('{"action":"exit_short"}', title="Ïàè Ï≤≠ÏÇ∞", group=gMsg)

// =================================================================================
// === Î≥¥Ï°∞ Í≥ÑÏÇ∞ ==================================================================
// =================================================================================

// --- Heikin-Ashi Î≥ÄÌôò ---
float haClose = (open + high + low + close) / 4.0
var float haOpen = na
haOpen := na(haOpen[1]) ? (open + close) / 2.0 : (haOpen[1] + haClose[1]) / 2.0
float haHigh = math.max(high, math.max(haOpen, haClose))
float haLow  = math.min(low,  math.min(haOpen, haClose))

float srcClose = dfh ? haClose : close

// --- ÌîåÎü≠Ïä§ Í≥ÑÏÇ∞ (Deluxe Î∞©Ïãù) ---
float fluxHigh   = dfh ? haHigh : high
float fluxLow    = dfh ? haLow  : low
float fluxClose  = srcClose
float prevClose  = nz(fluxClose[1], fluxClose)
float upMove     = fluxHigh - nz(fluxHigh[1], fluxHigh)
float downMove   = nz(fluxLow[1], fluxLow) - fluxLow
float trRaw      = math.max(fluxHigh - fluxLow, math.max(math.abs(fluxHigh - prevClose), math.abs(fluxLow - prevClose)))
float tr         = ta.rma(trRaw, dfl)
float upRma      = ta.rma(math.max(upMove, 0.0), dfl)
float downRma    = ta.rma(math.max(downMove, 0.0), dfl)
float trSafe     = tr == 0.0 ? na : tr
float up         = not na(trSafe) ? upRma / trSafe : 0.0
float dn         = not na(trSafe) ? downRma / trSafe : 0.0
float fluxDenom  = up + dn
float fluxRatio  = fluxDenom != 0 ? (up - dn) / fluxDenom : 0.0
int   fluxHalf   = math.max(int(math.round(dfl / 2.0)), 1)
float fluxCore   = ta.rma(fluxRatio, fluxHalf) * 100.0
float fluxValOriginal = dfSmoothLen > 1 ? ta.sma(fluxCore, dfSmoothLen) : fluxCore

// Î™®ÎîîÌååÏù¥Îìú Î∞©Ìñ•ÏÑ± ÌîåÎü≠Ïä§ (DMI/ADX) Í≥ÑÏÇ∞
float pdi       = ta.plus_di(dfl)
float ndi       = ta.minus_di(dfl)
float dden      = pdi + ndi
float modFluxRatio = dden != 0 ? (pdi - ndi) / dden : 0.0
int   modFluxHalf   = math.max(int(math.round(dfl / 2.0)), 1)
float modFluxCore   = ta.rma(modFluxRatio, modFluxHalf) * 100.0
float modFluxVal    = dfSmoothLen > 1 ? ta.sma(modFluxCore, dfSmoothLen) : modFluxCore

// ÏµúÏ¢Ö ÏÇ¨Ïö©Îê† ÌîåÎü≠Ïä§
float fluxVal    = useModFlux ? modFluxVal : fluxValOriginal

// --- Ïä§ÌÄ¥Ï¶à Î™®Î©òÌÖÄ Í≥ÑÏÇ∞ ---
// Bollinger Band Í∏∞Ï§ÄÏÑ†: Ï¢ÖÍ∞ÄÏùò Ïù¥ÎèôÌèâÍ∑†ÏúºÎ°ú Í≥ÑÏÇ∞Ìï©ÎãàÎã§. kcLen ÏùÑ ÏÇ¨Ïö©ÌïòÏó¨ KC Í∏∏Ïù¥ÏôÄ ÏùºÏπòÏãúÌÇµÎãàÎã§.
float bbBasis     = ta.sma(close, kcLen)
float bbDev       = ta.stdev(close, bbLen) * bbMult
float kcRange     = ta.atr(kcLen) * kcMult
bool squeezeOn    = bbDev < kcRange

// Í≥µÌÜµ ÏÑ†Í≥ÑÏÇ∞
float hl2         = (high + low) / 2.0
// KC Ï±ÑÎÑê Î∞è midline
float kcBasis     = ta.sma(hl2, kcLen)
float kcUpper     = kcBasis + kcRange
float kcLower     = kcBasis - kcRange
float kcAverage   = (kcUpper + kcLower) / 2.0
float midline     = math.avg(hl2, kcAverage)
float atrPrimary  = ta.atr(kcLen)

// ÏµúÍ≥†/ÏµúÏ†Ä Í∏∞Î∞ò KC Ï§ëÏã¨Í∞í (KC Ïä§ÌÉÄÏùº)
float highestHigh = ta.highest(high, kcLen)
float lowestLow   = ta.lowest(low, kcLen)
float meanKC      = (highestHigh + lowestLow) / 2.0

// AVG Ïä§ÌÉÄÏùºÏùÑ ÏúÑÌïú BB Î∞è Ï§ëÏïôÍ∞í ÌèâÍ∑†ÏÑ†
float avgLineAvg  = (bbBasis + meanKC) / 2.0

// Deluxe Ïä§ÌÉÄÏùºÏùÑ ÏúÑÌïú hl2 Í∏∞Î∞ò BB Ï§ëÍ∞ÑÏÑ†Í≥º meanKC ÌèâÍ∑†ÏÑ†
float bbMidHl2    = ta.sma(hl2, kcLen)
float avgLineDeluxe = (meanKC + bbMidHl2) / 2.0

// Î™®Î©òÌÖÄ ÏûÖÎ†•Í∞í: Ïä§ÌÉÄÏùºÏóê Îî∞Îùº Îã§Î•∏ Í∏∞Ï§ÄÏÑ†Í≥º ATR Ï†ïÍ∑úÌôîÎ•º Ï†ÅÏö©Ìï©ÎãàÎã§.
float normKC    = close - meanKC
float normAVG   = atrPrimary > 0 ? (close - avgLineAvg) / atrPrimary : 0.0
float normDeluxe= close - avgLineDeluxe
float normMod   = atrPrimary > 0 ? (close - midline) / atrPrimary : 0.0

// ÏÑ†ÌÉùÎêú Î™®Î©òÌÖÄ Ïä§ÌÉÄÏùºÏóê Îî∞Îùº norm Í∞íÏùÑ Í≥†Î¶ÖÎãàÎã§.  Í∏∞Î≥∏Í∞íÏùÄ "KC" ÏûÖÎãàÎã§.
float normSel = normKC
if momStyle == "AVG"
    normSel := normAVG
else if momStyle == "Deluxe"
    normSel := normDeluxe
else if momStyle == "Mod"
    normSel := normMod

// 100 Î∞∞Ïú®ÏùÑ ÎßûÏ∂∞ ÎπÑÍµêÏ†Å ÏùºÍ¥ÄÎêú ÌÅ¨Í∏∞Î•º Ïú†ÏßÄÌï©ÎãàÎã§.
float momentum    = ta.linreg(normSel * 100.0, len, 0)
// Î™®Î©òÌÖÄ Ïã†Ìò∏ÏÑ† ÌÉÄÏûÖÎ≥Ñ Í≥ÑÏÇ∞
float momSignal   = na
if maType == "EMA"
    momSignal := ta.ema(momentum, sig)
else if maType == "HMA"
    momSignal := ta.hma(momentum, sig)
else
    momSignal := ta.sma(momentum, sig)

// --- ÌéòÏù¥Îìú Í∞êÏßÄ ---
int fadeWindow = 1
bool fadeMagnitudeDown = ta.falling(math.abs(momentum), fadeWindow)
bool fadeLongCond_vn  = momentum > 0 and fadeMagnitudeDown
bool fadeShortCond_vn = momentum < 0 and fadeMagnitudeDown
bool fadeLongCond_lg  = momentum > 0 and momentum <= nz(momentum[1], momentum)
bool fadeShortCond_lg = momentum < 0 and momentum >= nz(momentum[1], momentum)
bool fadeLongCond  = fadeMode == "VN" ? fadeLongCond_vn  : fadeLongCond_lg
bool fadeShortCond = fadeMode == "VN" ? fadeShortCond_vn : fadeShortCond_lg

// --- ÏÉÅÏúÑÎ¥â ÌïÑÌÑ∞ ---
// ÏÉÅÏúÑÎ¥â ÌïÑÌÑ∞Îäî ÏÇ¨Ïö© ÏãúÏóêÎßå Í≥ÑÏÇ∞
float htfMa      = na
bool htfTrendUp  = false
bool htfTrendDown= false
if useHtfTrend
    htfMa      := request.security(syminfo.tickerid, htfTrendTf, ta.ema(close, htfMaLen), lookahead=barmerge.lookahead_off)
    htfTrendUp   := close > htfMa
    htfTrendDown := close < htfMa

// --- Î†àÏù∏ÏßÄ ÌïÑÌÑ∞ ---
float rangeHigh   = na
float rangeLow    = na
float rangePerc   = na
bool  inRangeBox  = false
if useRangeFilter
    rangeHigh   := request.security(syminfo.tickerid, rangeTf, ta.highest(high, rangeBars), lookahead=barmerge.lookahead_off)
    rangeLow    := request.security(syminfo.tickerid, rangeTf, ta.lowest(low, rangeBars),  lookahead=barmerge.lookahead_off)
    rangePerc   := rangeLow != 0 ? (rangeHigh - rangeLow) / rangeLow * 100.0 : 0.0
    inRangeBox  := rangePerc <= rangePercent

float pivotLow = ta.valuewhen(not na(ta.pivotlow(low, pivotLen, pivotLen)), ta.pivotlow(low, pivotLen, pivotLen), 0)
float pivotHigh = ta.valuewhen(not na(ta.pivothigh(high, pivotLen, pivotLen)), ta.pivothigh(high, pivotLen, pivotLen), 0)
float swingLow = ta.lowest(low, stopLookback)
float swingHigh = ta.highest(high, stopLookback)
float atrBase = ta.atr(len)
float atrTrailBase = ta.atr(atrTrailLen)

// =================================================================================
// === Ïã†Ìò∏ & Ïã§Ìñâ =================================================================
// =================================================================================

bool longSignal  = ta.crossover(momentum, momSignal) and momentum < 0 and fluxVal > 0
bool shortSignal = ta.crossunder(momentum, momSignal) and momentum > 0 and fluxVal < 0

bool longFilterOk  = (not useHtfTrend or htfTrendUp)   and (not useRangeFilter or not inRangeBox)
bool shortFilterOk = (not useHtfTrend or htfTrendDown) and (not useRangeFilter or not inRangeBox)

bool enterLong  = longSignal  and longFilterOk
bool enterShort = shortSignal and shortFilterOk

bool exitLongOpposite  = exitOpposite and shortSignal
bool exitShortOpposite = exitOpposite and longSignal
bool exitLongFade      = useMomFade and fadeLongCond
bool exitShortFade     = useMomFade and fadeShortCond

var float highestSinceEntry = na
var float lowestSinceEntry  = na
var int   holdBars          = 0

var float withdrawable      = 0.0
var float effectiveEquity   = strategy.initial_capital
var float tradableCapital   = strategy.initial_capital
var float peakEquity        = strategy.initial_capital
var float dailyStartCapital = strategy.initial_capital
var float dailyPeakCapital  = strategy.initial_capital
var float prevNetProfit     = 0.0
var int   dailyLosses       = 0
var int   lossStreak        = 0
var bool  guardFrozen       = false
var bool  prevGuardFrozen   = false

if barstate.isconfirmed
    bool newDay = ta.change(time("D")) != 0
    if newDay
        dailyStartCapital := tradableCapital
        dailyPeakCapital := tradableCapital
        dailyLosses := 0
        guardFrozen := false

    float netProfit = strategy.netprofit
    float openProfit = strategy.openprofit
    float accountEquity = strategy.initial_capital + netProfit + openProfit

    if useWallet
        if netProfit > 0
            withdrawable += netProfit * (profitReservePct / 100.0)
        withdrawable := math.min(withdrawable, math.max(accountEquity, 0.0))
    else
        withdrawable := 0.0

    float adjustedEquityValue = useWallet and applyReserveToSizing ? (accountEquity - withdrawable) : accountEquity
    adjustedEquityValue := math.max(adjustedEquityValue, strategy.initial_capital * 0.01)
    effectiveEquity := adjustedEquityValue
    tradableCapital := adjustedEquityValue
    peakEquity := math.max(peakEquity, accountEquity)
    dailyPeakCapital := math.max(dailyPeakCapital, tradableCapital)

    float profitDelta = netProfit - prevNetProfit
    if profitDelta < 0
        lossStreak += 1
        dailyLosses += 1
    else if profitDelta > 0
        lossStreak := 0
    prevNetProfit := netProfit

    float dailyPnl = tradableCapital - dailyStartCapital
    bool dailyLossBreached = useDailyLossGuard and dailyPnl <= -math.abs(dailyLossLimit)
    bool lossStreakBreached = useLossStreakGuard and lossStreak >= maxConsecutiveLosses
    bool lossCountBreached = maxDailyLosses > 0 and dailyLosses >= maxDailyLosses
    bool capitalBreached = tradableCapital < minTradableCapital
    bool guardHit = dailyLossBreached or lossStreakBreached or lossCountBreached or capitalBreached
    if guardHit
        guardFrozen := true

    bool guardActivated = guardFrozen and not prevGuardFrozen
    prevGuardFrozen := guardFrozen

    if guardActivated
        if strategy.position_size > 0
            strategy.close("Long", alert_message=alertExitLong)
        else if strategy.position_size < 0
            strategy.close("Short", alert_message=alertExitShort)

    float tradeQtyValue = close > 0 ? (tradableCapital * math.max(baseQtyPercent, 0.0) / 100.0) * leverage / close : 0.0
    bool canTrade = not guardFrozen and tradeQtyValue > 0

    if strategy.position_size == 0
        holdBars := 0
        highestSinceEntry := na
        lowestSinceEntry := na
        strategy.cancel("LongStop")
        strategy.cancel("ShortStop")
        if canTrade and enterLong
            strategy.entry("Long", strategy.long, qty=tradeQtyValue, alert_message=alertLongEntry)
        if canTrade and enterShort
            strategy.entry("Short", strategy.short, qty=tradeQtyValue, alert_message=alertShortEntry)
    else
        if not guardActivated
            holdBars += 1
            if strategy.position_size > 0
                highestSinceEntry := na(highestSinceEntry) ? high : math.max(highestSinceEntry, high)
                float breakevenStop = na
                if useBreakeven and not na(highestSinceEntry) and not na(atrTrailBase)
                    breakevenStop := (highestSinceEntry - strategy.position_avg_price) >= atrTrailBase * breakevenMult ? strategy.position_avg_price : na
                float trailStop = useAtrTrail and not na(highestSinceEntry) and not na(atrTrailBase) ? highestSinceEntry - atrTrailMult * atrTrailBase : na
                float combinedStop = na
                if useBreakeven and not na(breakevenStop)
                    combinedStop := breakevenStop
                if useStopLoss and not na(swingLow)
                    combinedStop := na(combinedStop) ? swingLow : math.max(combinedStop, swingLow)
                if usePivotStop and not na(pivotLow)
                    combinedStop := na(combinedStop) ? pivotLow : math.max(combinedStop, pivotLow)
                if useAtrTrail and not na(trailStop)
                    combinedStop := na(combinedStop) ? trailStop : math.max(combinedStop, trailStop)
                if useFixedStop
                    float fixedStop = strategy.position_avg_price * (1 - fixedStopPct / 100.0)
                    combinedStop := na(combinedStop) ? fixedStop : math.max(combinedStop, fixedStop)
                if useAtrStop and not na(atrBase)
                    float atrStopVal = strategy.position_avg_price - atrBase * atrStopMult
                    combinedStop := na(combinedStop) ? atrStopVal : math.max(combinedStop, atrStopVal)
                if not na(combinedStop)
                    strategy.exit("LongStop", from_entry="Long", stop=combinedStop, alert_message=alertExitLong)
                if useTimeStop and maxHoldBars > 0 and holdBars >= maxHoldBars
                    strategy.close("Long", alert_message=alertExitLong)
                else if exitLongOpposite or (exitLongFade and holdBars >= 1)
                    strategy.close("Long", alert_message=alertExitLong)
            else if strategy.position_size < 0
                lowestSinceEntry := na(lowestSinceEntry) ? low : math.min(lowestSinceEntry, low)
                float breakevenStop = na
                if useBreakeven and not na(lowestSinceEntry) and not na(atrTrailBase)
                    breakevenStop := (strategy.position_avg_price - lowestSinceEntry) >= atrTrailBase * breakevenMult ? strategy.position_avg_price : na
                float trailStop = useAtrTrail and not na(lowestSinceEntry) and not na(atrTrailBase) ? lowestSinceEntry + atrTrailMult * atrTrailBase : na
                float combinedStop = na
                if useBreakeven and not na(breakevenStop)
                    combinedStop := breakevenStop
                if useStopLoss and not na(swingHigh)
                    combinedStop := na(combinedStop) ? swingHigh : math.min(combinedStop, swingHigh)
                if usePivotStop and not na(pivotHigh)
                    combinedStop := na(combinedStop) ? pivotHigh : math.min(combinedStop, pivotHigh)
                if useAtrTrail and not na(trailStop)
                    combinedStop := na(combinedStop) ? trailStop : math.min(combinedStop, trailStop)
                if useFixedStop
                    float fixedStop = strategy.position_avg_price * (1 + fixedStopPct / 100.0)
                    combinedStop := na(combinedStop) ? fixedStop : math.min(combinedStop, fixedStop)
                if useAtrStop and not na(atrBase)
                    float atrStopVal = strategy.position_avg_price + atrBase * atrStopMult
                    combinedStop := na(combinedStop) ? atrStopVal : math.min(combinedStop, atrStopVal)
                if not na(combinedStop)
                    strategy.exit("ShortStop", from_entry="Short", stop=combinedStop, alert_message=alertExitShort)
                if useTimeStop and maxHoldBars > 0 and holdBars >= maxHoldBars
                    strategy.close("Short", alert_message=alertExitShort)
                else if exitShortOpposite or (exitShortFade and holdBars >= 1)
                    strategy.close("Short", alert_message=alertExitShort)

// =================================================================================
// === ÏãúÍ∞ÅÌôî =====================================================================
// =================================================================================

hline(0, title="Zero", color=color.new(color.white, 80), linestyle=hline.style_dashed)
plot(showMomentum ? momentum : na, title="Momentum", color=momentum >= 0 ? colup : coldn, style=plot.style_columns)
plot(showMomentum ? momSignal : na, title="Momentum Signal", color=color.new(color.white, 0))
plot(showFlux ? fluxVal : na, title="Directional Flux", color=fluxVal >= 0 ? colps : colng)
plotshape(enterLong , title="Long Entry" , style=shape.triangleup  , location=location.belowbar, color=colpo, size=size.tiny)
plotshape(enterShort, title="Short Entry", style=shape.triangledown, location=location.abovebar, color=colno, size=size.tiny)
plotshape(exitLongOpposite or exitLongFade , title="Long Exit" , style=shape.circle, location=location.abovebar, color=colpf, size=size.tiny)
plotshape(exitShortOpposite or exitShortFade, title="Short Exit", style=shape.circle, location=location.belowbar, color=coldf, size=size.tiny)
barcolor(squeezeOn ? color.new(colsh, 70) : na)

// --- ÏñºÎüø ---
alertcondition(enterLong , "Enter Long" , "Enter Long")
alertcondition(enterShort, "Enter Short", "Enter Short")
alertcondition(exitLongOpposite or exitLongFade , "Exit Long" , "Exit Long")
alertcondition(exitShortOpposite or exitShortFade, "Exit Short", "Exit Short")
