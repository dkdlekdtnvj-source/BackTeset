version: 1

overrides:
  altEngine: vectorbt

search:
  algo: bayes
  n_trials: 1000
  seed: 42
  top_k: 5
  dataset_executor: process
  allow_sqlite_parallel: false   # true=병렬 허용을 명시, false=병렬 유지하되 잠금 충돌 시 자동 재시도(경고 출력)
  # 기본 병렬: 스토리지 타입에 맞춰 run.py에서 CPU 코어 수 기반으로 자동 설정됩니다.
  storage_url_env: OPTUNA_STORAGE   # 외부 RDB URL을 환경변수로 전달하면 SQLite 대신 사용합니다.
  storage_pool_size: 8                  # PostgreSQL 풀 커넥션 수 (기본 8)
  storage_max_overflow: 16              # 풀 초과 시 임시 커넥션 수
  storage_pool_timeout: 30              # 풀에서 커넥션을 기다리는 최대 초 (0=무제한)
  storage_pool_recycle: 1800            # 커넥션 재생성 주기(초)
  storage_connect_timeout: 10           # DB 커넥션 시도 타임아웃(초)
  storage_statement_timeout_ms: 300000  # 쿼리 타임아웃(밀리초). 0 또는 비우면 비활성화
  storage_isolation_level: READ COMMITTED  # PostgreSQL 권장 격리 수준
  diversify:
    enabled: true
    similarity_threshold: 0.9   # 최근 트라이얼과 90% 이상 동일하면 정체로 간주
    max_consecutive: 6          # 연속 6회 이상 반복되면 강제 점프
    jump_trials: 3              # 큐에 주입할 랜덤/돌연변이 후보 수
    history_bias: 0.4           # 일부는 최근 성공 파라미터 주변을 탐색
    timeframe_cycle:            # 1분 5회 → 3분 3회 → 5분 1회 루프 예시
      - timeframe: "1m"
        repeat: 5
      - timeframe: "3m"
        repeat: 3
      - timeframe: "5m"
        repeat: 1

# === 엔진/성능 옵션 ===
useNumba: true          # Numba JIT 사용 (없으면 기본 false)
vectorizedCross: true   # 모멘텀 교차 사전계산(이미 기본 true 권장)
strictStartDate: false  # 데이터 시작으로 자동 보정 ON
logNoTradeReasons: false

objective:
  # === 기본룰: ProfitFactor 중심 ===
  - name: ProfitFactor
    weight: 1.0
  - name: Trades
    weight: 0.2
  # --- 토글 시작: 최대 손실폭(MaxDD) 목표 추가 ---
  - name: MaxDD
    goal: minimize  # MaxDD는 낮을수록 좋으니까 'minimize'로 설정
    weight: 0.5     # 이 가중치가 높을수록 DD가 낮은 안정적인 전략을 더 선호하게 돼
  # --- 토글 끝 ---
constraints:
  min_trades_test: 50   # 최소 거래 수. 거래수가 50 미만이면 학습 점수에 반영하지 않습니다.
  max_dd_pct: 70        # MaxDD 70% 초과면 패널티

space:
# === 스퀴즈 모멘텀 전략 최적화 공간 ===

  # --- 1. 핵심 오실레이터 설정 ---
  # 모멘텀 오실레이터 길이(oscLen)와 신호 길이(signalLen)는 회귀 및 스무딩 길이를 결정하며
  # 스퀴즈 감지 파라미터와는 독립적으로 작동합니다.
  oscLen:         { type: int,   min: 10,  max: 30, step: 1 }
  signalLen:      { type: int,   min: 2,   max: 7, step: 1 }
  # 볼린저 밴드 길이/배수 (오실레이터 계산에 사용)
  bbLen:          { type: int,   min: 5,  max: 30, step: 1 }
  bbMult:         { type: float, min: 1.0, max: 3.0, step: 0.1 }

  # --- 2. 스퀴즈 감지용 KC 채널 ---
  # Keltner Channel(KC) 파라미터로 스퀴즈를 감지합니다.  모멘텀 계산 스타일은 `momStyle`
  # 파라미터를 통해 선택됩니다.  KC 스타일은 최고가/최저가의 평균을 기준으로 계산하고,
  # AVG 스타일은 볼린저밴드 중간선과 KC 평균선의 평균을 사용하며, Deluxe 스타일은
  # hl2 기반 중간선(최고/최저 기반)과 볼린저 중간선을 평균해 사용합니다.  Mod 스타일은
  # midline(hl2+KC 중간값)을 ATR 로 정규화한 값으로 모멘텀을 계산합니다.
  kcLen:          { type: int,   min: 5,  max: 40, step: 1 }
  kcMult:         { type: float, min: 1.0, max: 2.5, step: 0.1 }

  # --- 3. 방향성 플럭스 ---
  fluxLen:        { type: int,   min: 5,  max: 30, step: 1 }
  fluxSmoothLen:  { type: int,   min: 1,   max: 10,  step: 1 }
  useFluxHeikin:  { type: bool }
  useModFlux:     { type: bool }
  momStyle:       { type: choice, values: [KC, AVG, Deluxe, Mod] }
  maType:         { type: choice, values: [SMA, EMA, HMA] }

  # --- 4. 동적 임계값 및 진입 조건 ---
  useDynamicThresh:     { type: bool }
  useSymThreshold:      { type: bool }
  statThreshold:        { type: float, min: 30.0, max: 70.0, step: 2.0 }
  buyThreshold:         { type: float, min: 30.0, max: 70.0, step: 2.0 }
  sellThreshold:        { type: float, min: 30.0, max: 70.0, step: 2.0 }
  dynLen:               { type: int,   min: 10,  max: 60, step: 1 }
  dynMult:              { type: float, min: 0.8, max: 3.0, step: 0.1 }

  # --- 5. 청산 로직 ---
  exitOpposite:   { type: bool }
  useMomFade:     { type: bool }
  momFadeRegLen:  { type: int,   min: 10, max: 30, step: 1 }
  momFadeBbLen:   { type: int,   min: 10, max: 30, step: 1 }
  momFadeKcLen:   { type: int,   min: 10, max: 40, step: 1 }
  momFadeBbMult:  { type: float, min: 1.5, max: 3.0, step: 0.1 }
  momFadeKcMult:  { type: float, min: 1.0, max: 3.0, step: 0.1 }

  # Note: Risk parameters (stop loss, position sizing) are not optimised
  # here; adjust `risk` block below if you wish to customise leverage/slippage.

risk:
  leverage: 10
  fee_pct: 0.0006
  slippage_ticks: 3

# --- LLM assistant configuration ---
# To enable Gemini‑assisted parameter proposals, set `enabled: true` and provide
# a valid API key. The loader checks the following keys in order: `api_key`,
# `api_key_file`/`api_key_path`, `api_key_env` (defaults to `GEMINI_API_KEY`),
# and `.env` files located in the working directory, repository root, or
# `config/.env`. The default model points to the latest Gemini 2.5 Flash
# preview; override it if Google renames the model after the preview phase.
# `initial_trials` controls how many Optuna trials are executed before
# consulting the LLM. `top_n` determines how many top trials are summarised,
# and `count` sets the number of candidate suggestions to enqueue.
# `thinking_budget` is optional and applies only to Gemini 2.5 models, tuning
# the internal reasoning cost (0 disables thinking; higher values allow deeper
# reasoning but increase latency/cost).
llm:
  enabled: true
  api_key_env: GEMINI_API_KEY
  # api_key: "..."               # 직접 입력 (권장 X)
  # api_key_file: ~/.secrets/gemini.key
  model: gemini-flash-latest
  top_n: 10
  count: 8
  initial_trials: 20
  thinking_budget: 1024
