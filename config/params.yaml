version: 1

search:
  algo: bayes
  n_trials: 1000
  seed: 42
  top_k: 5
  n_jobs: 4
  dataset_jobs: 2
  dataset_executor: process
  allow_sqlite_parallel: false
  # 기본 병렬: run.py에서 자동 설정(n_jobs=자동)

# === 엔진/성능 옵션 ===
useNumba: true          # Numba JIT 사용 (없으면 기본 false)
vectorizedCross: true   # 모멘텀 교차 사전계산(이미 기본 true 권장)
strictStartDate: false  # 데이터 시작으로 자동 보정 ON
logNoTradeReasons: false

objective:
  # === 기본룰: ProfitFactor 중심 ===
  - name: ProfitFactor
    weight: 1.0

constraints:
  min_trades_test: 12   # 테스트 구간에서 최소 거래 수 (없으면 강한 패널티)
  max_dd_pct: 70        # MaxDD 70% 초과면 패널티

space:
  # Optimisation search space tuned for the Squeeze Momentum Deluxe strategy.
  #
  # Only the core oscillator, signal, volatility channel and fade‑exit
  # parameters are swept.  All other features (filters, dynamic thresholds,
  # alternative exits) remain at their default values.  See `optimize/run.py`
  # for the basic factor key set used by `--basic-factors-only`.

  # --- Oscillator & signal lengths ---
  oscLen:         { type: int,   min: 8,   max: 48, step: 2 }
  signalLen:      { type: int,   min: 1,   max: 12, step: 1 }

  # --- Volatility channels (Bollinger & Keltner) ---
  bbLen:          { type: int,   min: 12, max: 30, step: 2 }
  bbMult:         { type: float, min: 1.5, max: 2.5, step: 0.25 }
  kcLen:          { type: int,   min: 12, max: 30, step: 2 }
  kcMult:         { type: float, min: 1.0, max: 2.0, step: 0.2 }

  # --- Directional flux ---
  fluxLen:        { type: int,   min: 8,   max: 40, step: 2 }
  fluxSmoothLen:  { type: int,   min: 1,   max: 10, step: 1 }
  useFluxHeikin:  { type: bool }

  # --- Dynamic threshold & momentum gate ---
  useDynamicThresh:     { type: bool }
  useSymThreshold:      { type: bool }
  statThreshold:        { type: float, min: 20.0, max: 80.0, step: 2.0 }
  buyThreshold:         { type: float, min: 20.0, max: 60.0, step: 2.0 }
  sellThreshold:        { type: float, min: 20.0, max: 60.0, step: 2.0 }
  dynLen:               { type: int,   min: 10,  max: 60, step: 1 }
  dynMult:              { type: float, min: 0.8, max: 1.8, step: 0.05 }
  requireMomentumCross: { type: bool }

  # --- Exit logic ---
  exitOpposite:   { type: bool }
  useMomFade:     { type: bool }
  momFadeRegLen:  { type: int,   min: 10, max: 40, step: 2 }
  momFadeBbLen:   { type: int,   min: 10, max: 40, step: 2 }
  momFadeKcLen:   { type: int,   min: 10, max: 40, step: 2 }
  momFadeBbMult:  { type: float, min: 1.5, max: 3.0, step: 0.25 }
  momFadeKcMult:  { type: float, min: 1.0, max: 3.0, step: 0.25 }

  # Note: Risk parameters (stop loss, position sizing) are not optimised
  # here; adjust `risk` block below if you wish to customise leverage/slippage.

risk:
  leverage: 10
  fee_pct: 0.0006
  slippage_ticks: 3

# --- LLM assistant configuration ---
# To enable Gemini‑assisted parameter proposals, set `enabled: true` and provide
# a valid API key via `api_key` or `api_key_env`. The default model points to
# the latest Gemini 2.5 Flash preview; override it if Google renames the model
# after the preview phase. `initial_trials` controls how many Optuna trials are
# executed before consulting the LLM. `top_n` determines how many top trials
# are summarised, and `count` sets the number of candidate suggestions to
# enqueue. `thinking_budget` is optional and applies only to Gemini 2.5 models,
# tuning the internal reasoning cost (0 disables thinking; higher values allow
# deeper reasoning but increase latency/cost).
llm:
  enabled: false
  api_key_env: GEMINI_API_KEY
  model: gemini-2.5-flash-preview-04-17
  top_n: 10
  count: 8
  initial_trials: 20
  thinking_budget: 1024
